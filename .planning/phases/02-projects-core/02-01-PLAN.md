---
phase: 02-projects-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/views/projects.js
  - app/utils.js
autonomous: true

must_haves:
  truths:
    - "User can create project with client dropdown selection"
    - "Project code auto-generates in format CLMC_CLIENT_YYYY###"
    - "User can select Internal Status from 4 predefined options"
    - "User can select Project Status from 7 predefined options"
    - "User can enter optional budget and contract_cost (positive numbers only)"
    - "User can edit existing project information"
    - "User can delete projects with confirmation"
    - "User can toggle project active/inactive status"
  artifacts:
    - path: "app/views/projects.js"
      provides: "Project CRUD operations view module"
      min_lines: 600
      exports: ["render", "init", "destroy"]
    - path: "app/utils.js"
      provides: "Composite project code generation function"
      contains: "generateProjectCode"
  key_links:
    - from: "app/views/projects.js"
      to: "Firebase clients collection"
      via: "onSnapshot for dropdown population"
      pattern: "onSnapshot.*collection.*clients"
    - from: "app/views/projects.js"
      to: "Firebase projects collection"
      via: "CRUD operations"
      pattern: "collection.*projects"
    - from: "app/views/projects.js"
      to: "app/utils.js generateProjectCode()"
      via: "import and function call"
      pattern: "generateProjectCode"
---

<objective>
Create complete project management view module with auto-generated composite project codes, dual-status tracking, client dropdown population, and CRUD operations following the proven clients.js pattern.

Purpose: Establish project database and CRUD interface as the core foundation for the procurement system. Projects are the anchor entity that all MRFs will reference.

Output: Working project management interface with real-time sync, composite ID generation, client selection, dual status fields, optional numeric validation, and active/inactive toggle.
</objective>

<execution_context>
@C:\Users\franc\dev\projects\pr-po\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\franc\dev\projects\pr-po\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@C:\Users\franc\dev\projects\pr-po\.planning\PROJECT.md
@C:\Users\franc\dev\projects\pr-po\.planning\ROADMAP.md
@C:\Users\franc\dev\projects\pr-po\.planning\STATE.md
@C:\Users\franc\dev\projects\pr-po\.planning\REQUIREMENTS.md
@C:\Users\franc\dev\projects\pr-po\.planning\phases\02-projects-core\02-RESEARCH.md
@C:\Users\franc\dev\projects\pr-po\.planning\phases\01-clients-foundation\01-01-SUMMARY.md
@C:\Users\franc\dev\projects\pr-po\CLAUDE.md
@C:\Users\franc\dev\projects\pr-po\app\views\clients.js
@C:\Users\franc\dev\projects\pr-po\app\utils.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create composite project code generator in utils.js</name>
  <files>app/utils.js</files>
  <action>
Add `generateProjectCode(clientCode, year = null)` function to app/utils.js following the pattern in 02-RESEARCH.md (lines 93-127).

Implementation:
1. Accept clientCode (e.g., "ACME") and optional year parameter (defaults to current year)
2. Query Firebase projects collection with composite range query:
   - where('client_code', '==', clientCode)
   - where('project_code', '>=', `CLMC_${clientCode}_${currentYear}000`)
   - where('project_code', '<=', `CLMC_${clientCode}_${currentYear}999`)
3. Parse existing project codes using regex to extract sequential number: `/^CLMC_.+_\d{4}(\d{3})$/`
   - This handles client codes with underscores correctly (e.g., ACME_INC)
   - Don't use naive split('_') which breaks on underscore-containing client codes
4. Find max number, increment by 1
5. Return formatted code: `CLMC_${clientCode}_${currentYear}${String(newNum).padStart(3, '0')}`
6. Handle errors by logging and rethrowing

Example output: CLMC_ACME_2026001, CLMC_ACME_2026002, CLMC_XYZ_2026001

**Why regex not split:** Client codes can contain underscores (CLIENT-05 allows manual entry). Naive split('_') would break parsing. Regex matches pattern and captures the 3-digit number reliably.

Export the function for use in projects.js.
  </action>
  <verify>
1. Read app/utils.js and confirm generateProjectCode function exists
2. Verify regex pattern used for parsing (not split)
3. Verify query uses year-specific range
4. Check function is exported
  </verify>
  <done>
app/utils.js contains generateProjectCode() function that generates composite codes with client prefix, year, and 3-digit sequential number. Function handles underscore-containing client codes via regex parsing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create projects.js view module with CRUD operations</name>
  <files>app/views/projects.js</files>
  <action>
Create app/views/projects.js following the clients.js pattern (Phase 01-01) but with project-specific complexity. Use complete template from 02-RESEARCH.md (lines 586-954) as reference.

**Required imports:**
```javascript
import { db, collection, getDocs, addDoc, updateDoc, deleteDoc, doc, query, where, onSnapshot } from '../firebase.js';
import { showLoading, showToast, generateProjectCode } from '../utils.js';
```

**Global state:**
```javascript
let projectsData = [];
let clientsData = [];
let editingProject = null;
let currentPage = 1;
const itemsPerPage = 15;
let listeners = [];
```

**Status constants (PROJ-04, PROJ-05):**
```javascript
const INTERNAL_STATUS_OPTIONS = [
    'For Inspection',
    'For Proposal',
    'For Internal Approval',
    'Ready to Submit'
];

const PROJECT_STATUS_OPTIONS = [
    'Pending Client Review',
    'Under Client Review',
    'Approved by Client',
    'For Mobilization',
    'On-going',
    'Completed',
    'Loss'
];
```

**Module structure:**
1. **render()** - Returns HTML with:
   - Add project form (hidden by default) with fields:
     - Client dropdown (required, populated from Firestore)
     - Project name (required text input)
     - Internal Status (required dropdown from INTERNAL_STATUS_OPTIONS)
     - Project Status (required dropdown from PROJECT_STATUS_OPTIONS)
     - Budget (optional number, min="0", step="0.01")
     - Contract Cost (optional number, min="0", step="0.01")
     - Personnel (optional text input, freetext)
   - Projects table with columns: Code, Name, Client, Internal Status, Project Status, Active, Actions
   - Pagination controls

2. **init()** - Lifecycle initialization:
   - Call attachWindowFunctions()
   - Call loadClients() to set up client dropdown listener
   - Call loadProjects() to set up projects listener

3. **destroy()** - Cleanup:
   - Unsubscribe all listeners
   - Clear data arrays
   - Delete window functions
   - Log destruction

4. **loadClients()** - Client dropdown population (Pattern 2 from research):
   - Use onSnapshot on clients collection for real-time updates
   - Sort alphabetically by company_name
   - Call renderClientDropdown()
   - Store listener in listeners array

5. **renderClientDropdown()** - Populate client select:
   - Preserve current selection if editing
   - Build options: `<option value="${client.id}" data-code="${client.client_code}">${client.company_name} (${client.client_code})</option>`
   - Include data-code attribute for extracting client_code on save

6. **addProject()** - Create project:
   - Validate required fields (client, project_name, internal_status, project_status)
   - Validate optional positive numbers (budget > 0 OR null, contract_cost > 0 OR null)
     - Use `budgetVal ? parseFloat(budgetVal) : null`
     - Check `if (budget !== null && (isNaN(budget) || budget <= 0))` - reject zero per PROJ-17
   - Extract client_code from selected option's data-code attribute
   - Call await generateProjectCode(clientCode) to get project_code
   - Create document with fields: project_code, project_name, client_id, client_code (denormalized), internal_status, project_status, budget, contract_cost, personnel, active: true, created_at
   - Show success toast, hide form, auto-refresh via onSnapshot

7. **loadProjects()** - Real-time project list:
   - Use onSnapshot on projects collection
   - Sort by created_at descending (most recent first)
   - Call renderProjectsTable()
   - Store listener

8. **renderProjectsTable()** - Display projects:
   - Implement pagination (15 items per page)
   - For each project, find client from clientsData by client_id to display company_name
   - Show active/inactive badge with status-badge class
   - Edit and Delete buttons per row

9. **editProject(projectId)** - Inline editing:
   - Follow clients.js inline edit pattern
   - Load project data
   - Populate form fields including dropdowns (select correct option)
   - Change "Add Project" button to "Save" and "Cancel"

10. **saveEdit()** - Update project:
    - Same validation as addProject
    - Don't regenerate project_code (immutable after creation)
    - Update document with updated_at timestamp
    - Show success toast

11. **deleteProject(projectId, projectName)** - Delete with confirmation:
    - Confirm with project name in message
    - Delete from Firestore
    - Show success toast
    - Auto-refresh via onSnapshot

12. **toggleProjectActive(projectId, currentStatus)** - Toggle active flag (Pattern 5):
    - Confirm action
    - Update active field to !currentStatus
    - Add updated_at timestamp
    - Show success toast

13. **toggleAddProjectForm()** - Show/hide add form
14. **changeProjectsPage(page)** - Pagination handler
15. **updatePaginationControls()** - Pagination UI helper

**Window function attachment:**
```javascript
window.toggleAddProjectForm = toggleAddProjectForm;
window.addProject = addProject;
window.editProject = editProject;
window.saveEdit = saveEdit;
window.cancelEdit = cancelEdit;
window.deleteProject = deleteProject;
window.toggleProjectActive = toggleProjectActive;
window.changeProjectsPage = changeProjectsPage;
```

**Critical implementation notes:**
- Client dropdown must use onSnapshot (not getDocs) for real-time updates when new clients added
- Budget/contract_cost validation: `<= 0` not `< 0` to reject zero (PROJ-17 requires "positive")
- Store null for unset optional fields (not 0 or empty string)
- Denormalize client_code in project document for efficient filtering in Phase 3
- Project code is generated once at creation, never modified
- Status validation: check value exists in predefined arrays before save
- Active defaults to true for new projects

Follow the exact pattern from clients.js for: window functions, listeners cleanup, pagination logic, inline editing, real-time updates.
  </action>
  <verify>
1. Read app/views/projects.js
2. Confirm exports: render, init, destroy
3. Verify INTERNAL_STATUS_OPTIONS has 4 items
4. Verify PROJECT_STATUS_OPTIONS has 7 items
5. Verify budget/contract_cost validation uses `<= 0` (rejects zero)
6. Verify client dropdown uses onSnapshot (not getDocs)
7. Verify generateProjectCode imported from utils.js
8. Verify project document includes client_id AND client_code (denormalized)
9. Check listeners array cleanup in destroy()
10. Check window functions deleted in destroy()
  </verify>
  <done>
app/views/projects.js exists with complete CRUD operations, dual status dropdowns, client dropdown with real-time updates, composite project code generation, optional positive number validation, active/inactive toggle, pagination, and proper lifecycle management.
  </done>
</task>

</tasks>

<verification>
1. Manual test project creation:
   - Navigate to projects view (will be available after 02-02 router integration)
   - Create project selecting client, entering name, selecting statuses
   - Verify project code format: CLMC_CLIENTCODE_YYYY###
   - Verify project appears in table immediately (real-time update)

2. Test client dropdown real-time update:
   - Open projects view in one tab
   - Add new client in another tab (via clients view)
   - Return to projects view, click "Add Project"
   - Verify new client appears in dropdown without page refresh

3. Test optional field validation:
   - Create project with budget = 100.50 (should succeed)
   - Create project with budget = 0 (should fail with error toast)
   - Create project with budget = -50 (should fail)
   - Create project with budget blank (should succeed, stored as null)

4. Test dual status fields:
   - Create project with Internal Status "For Proposal", Project Status "Pending Client Review"
   - Verify both statuses appear correctly in table row
   - Edit project, change statuses, verify updates

5. Test project code generation:
   - Create 2 projects for client "ACME": should get CLMC_ACME_2026001, CLMC_ACME_2026002
   - Create 1 project for client "XYZ": should get CLMC_XYZ_2026001
   - Verify sequential numbering is per-client per-year

6. Browser console checks:
   - No errors during view init/destroy
   - [Projects] log messages appear
   - Firebase listeners properly attached/detached
</verification>

<success_criteria>
1. Users can create projects by selecting client, entering name, selecting dual statuses
2. Project codes auto-generate in format CLMC_CLIENT_YYYY### with per-client per-year uniqueness
3. Client dropdown populates from Firestore and updates in real-time when clients added
4. Internal Status dropdown has 4 options, Project Status dropdown has 7 options
5. Budget and contract_cost accept positive numbers or blank (null), reject zero and negative
6. Users can edit projects (all fields except project_code which is immutable)
7. Users can delete projects with confirmation dialog
8. Users can toggle active/inactive status
9. Project list displays with pagination (15 items per page)
10. Real-time updates: table refreshes when any project changes in Firestore
</success_criteria>

<output>
After completion, create `.planning/phases/02-projects-core/02-01-SUMMARY.md` following the template format from Phase 01-01.

Include:
- Performance metrics (duration, task count)
- Files created/modified
- Decisions made (especially budget validation interpretation)
- Next phase readiness (ready for 02-02 router integration)
</output>
