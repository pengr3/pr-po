---
phase: 05-core-authentication
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/views/login.js
  - app/router.js
  - app/auth.js
  - styles/views.css
autonomous: true

must_haves:
  truths:
    - "User can access login page via #/login URL"
    - "Login with valid credentials authenticates user"
    - "Session persists across browser refresh"
    - "Invalid credentials show generic error message"
  artifacts:
    - path: "app/views/login.js"
      provides: "Login view with form"
      exports: ["render", "init", "destroy"]
      min_lines: 100
    - path: "app/router.js"
      provides: "Route to login page"
      contains: "/login"
    - path: "app/auth.js"
      provides: "Auth state observer"
      contains: "onAuthStateChanged"
  key_links:
    - from: "app/views/login.js"
      to: "firebase/auth"
      via: "signInWithEmailAndPassword"
      pattern: "signInWithEmailAndPassword"
    - from: "app/auth.js"
      to: "app/firebase.js"
      via: "auth instance"
      pattern: "onAuthStateChanged"
---

<objective>
Create login page and establish session management with Firebase Auth state observer.

Purpose: Enable users to authenticate and maintain sessions across browser refreshes.
Output: Working login page at #/login with persistent session management.
</objective>

<execution_context>
@C:\Users\Admin\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Admin\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-core-authentication/05-CONTEXT.md
@.planning/phases/05-core-authentication/05-01-SUMMARY.md
@app/router.js
@app/auth.js
@styles/views.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create login view</name>
  <files>app/views/login.js, styles/views.css</files>
  <action>
    Create app/views/login.js following existing view patterns:

    1. render() function returns login form HTML:
       - Use same .auth-container, .auth-card classes from registration
       - CLMC logo at top
       - Title: "Sign In"
       - Form fields:
         - Email (email input, required)
         - Password (password input, required)
       - Sign In button (primary style)
       - Error message area (hidden by default)
       - Note: NO "forgot password" link, NO registration link (per CONTEXT.md)

    2. Match styling from registration page (reuse .auth-* classes)

    3. Add any additional CSS needed to styles/views.css if not covered by 05-02
  </action>
  <verify>
    - Navigate to #/login in browser
    - Form displays with email and password fields
    - UI matches registration page styling
    - No console errors
  </verify>
  <done>
    Login form renders with proper styling
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement login and session management</name>
  <files>app/views/login.js, app/auth.js</files>
  <action>
    Part A - Login submission in app/views/login.js:

    1. init() function:
       - Get form element and add submit handler
       - Attach window functions

    2. handleLogin() function:
       - Prevent default
       - Get email and password values
       - Clear previous errors

       Client-side validation:
       - Email: required
       - Password: required

       If validation fails: show inline errors, return

       If valid:
       - Show loading state on button
       - Call signInWithEmailAndPassword(auth, email, password)
       - On success: redirect to #/ (home) - the auth observer will handle routing based on status
       - On error: show "Invalid credentials" (generic message per CONTEXT.md)

    3. destroy() function:
       - Clean up event listeners
       - Remove window functions

    Part B - Auth state observer in app/auth.js:

    1. Add initAuthObserver() function:
       - Set up onAuthStateChanged listener
       - When user signs in:
         a. Fetch user document from Firestore
         b. Store user data in module-level variable (currentUser)
         c. Dispatch custom event 'authStateChanged' with user data
       - When user signs out:
         a. Clear currentUser
         b. Dispatch 'authStateChanged' with null

    2. Add getCurrentUser() function:
       - Return current authenticated user data (from Firestore, not just Firebase Auth)
       - Returns null if not authenticated

    3. Add isAuthenticated() function:
       - Returns true if user is authenticated

    4. Export these functions

    Note: Session persistence is automatic with browserLocalPersistence set in 05-01.
    Firebase handles the 1-day session and auto-renewal.
  </action>
  <verify>
    Test login flow:
    1. Navigate to #/login
    2. Submit empty form -> validation errors
    3. Submit with wrong credentials -> "Invalid credentials" error
    4. Create a test user in Firebase Auth console (or use the one from registration test)
    5. Login with valid credentials -> redirected to home
    6. Refresh browser -> still logged in (session persists)
    7. Check console: authStateChanged event fires on login
  </verify>
  <done>
    Login authenticates user, session persists across refresh, auth observer tracks state
  </done>
</task>

<task type="auto">
  <name>Task 3: Add login route</name>
  <files>app/router.js</files>
  <action>
    Add login route to router.js:

    1. Add to routes object:
       ```javascript
       '/login': {
           name: 'Login',
           load: () => import('./views/login.js'),
           title: 'Sign In | CLMC Procurement'
       }
       ```

    2. This route should be publicly accessible (no auth guard - comes in Phase 10)
  </action>
  <verify>
    - Navigate to #/login
    - View loads without errors
    - Title updates to "Sign In | CLMC Procurement"
  </verify>
  <done>
    Login route accessible via #/login
  </done>
</task>

</tasks>

<verification>
Complete login and session test:
1. Ensure a test user exists (from registration test or create manually in Firebase console)
2. Navigate to #/login
3. Login with valid credentials
4. Verify: redirected to home, console shows auth state change
5. Refresh browser
6. Verify: still authenticated (no redirect to login), auth state preserved
7. Open new tab to same URL
8. Verify: authenticated in new tab as well (session shared)
</verification>

<success_criteria>
- Login page accessible at #/login
- Valid credentials authenticate and redirect to home
- Invalid credentials show generic error
- Session persists across browser refresh
- Auth state observer tracks login/logout changes
</success_criteria>

<output>
After completion, create `.planning/phases/05-core-authentication/05-03-SUMMARY.md`
</output>
