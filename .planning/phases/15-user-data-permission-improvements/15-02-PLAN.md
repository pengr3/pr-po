---
phase: 15-user-data-permission-improvements
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/views/projects.js
  - app/views/project-detail.js
autonomous: true

must_haves:
  truths:
    - "Only operation_admin and super_admin roles see the Add Project button"
    - "Non-admin users cannot create projects even via console manipulation"
    - "Personnel field shows a searchable dropdown of active users when typing"
    - "Personnel field is required when creating a new project"
    - "Selecting a user from personnel dropdown stores their user ID (not just name)"
    - "Project detail page personnel field also uses the user datalist"
    - "Existing projects with freetext personnel display correctly"
  artifacts:
    - path: "app/views/projects.js"
      provides: "Role-guarded project creation and personnel user datalist"
      contains: "personnel_user_id"
    - path: "app/views/project-detail.js"
      provides: "Personnel user datalist in inline editing"
      contains: "usersList"
  key_links:
    - from: "app/views/projects.js render()"
      to: "window.getCurrentUser()"
      via: "Role check hides Add Project button for non-admin roles"
      pattern: "role.*super_admin.*operations_admin"
    - from: "app/views/projects.js addProject()"
      to: "window.getCurrentUser()"
      via: "Guard prevents project creation by non-admin roles"
      pattern: "role.*super_admin.*operations_admin"
    - from: "app/views/projects.js init()"
      to: "collection(db, 'users')"
      via: "onSnapshot listener populates personnel datalist"
      pattern: "onSnapshot.*users"
    - from: "app/views/projects.js addProject()"
      to: "personnel_user_id"
      via: "Validated datalist selection stored as user ID"
      pattern: "personnel_user_id"
---

<objective>
Restrict project creation to operation_admin and super_admin roles, and transform the personnel field from freetext into a validated user selection dropdown using HTML5 datalist.

Purpose: Enforces proper permission boundaries for project creation (success criteria #2) and establishes referential integrity for personnel assignments by storing user IDs instead of freetext names (success criteria #3, #4, #5). Firestore Security Rules already enforce server-side (line 119 of firestore.rules), so this adds client-side UX enforcement.

Output: Modified projects.js with role-guarded creation and personnel datalist. Modified project-detail.js with personnel datalist for inline editing.
</objective>

<execution_context>
@C:\Users\Admin\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Admin\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-user-data-permission-improvements/15-RESEARCH.md

@app/views/projects.js
@app/views/project-detail.js
@app/auth.js
@firestore.rules
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add role-based permission guard for project creation in projects.js</name>
  <files>app/views/projects.js</files>
  <action>
  Currently the "Add Project" button visibility is controlled by `canEditTab('projects')` which checks generic edit permission. We need an additional check specifically for project CREATION (only super_admin and operations_admin).

  1. In render() function (line ~72): Change the Add Project button visibility logic. Currently it uses `showEditControls` (which is `canEdit !== false`). Replace the button visibility with a more specific role check:
     ```javascript
     const user = window.getCurrentUser?.();
     const canCreateProject = user?.role === 'super_admin' || user?.role === 'operations_admin';
     ```
     Then use `canCreateProject` instead of `showEditControls` for the Add Project button ONLY. Keep `showEditControls` for Edit/Delete/Deactivate buttons in the table -- those are still governed by generic edit permission.

  2. In toggleAddProjectForm() function (line ~361): Add a role guard at the top (in addition to existing canEditTab check):
     ```javascript
     const user = window.getCurrentUser?.();
     if (!user || (user.role !== 'super_admin' && user.role !== 'operations_admin')) {
         showToast('Only Operations Admin and Super Admin can create projects', 'error');
         return;
     }
     ```

  3. In addProject() function (line ~396): Add the same role guard at the top (in addition to existing canEditTab check):
     ```javascript
     const user = window.getCurrentUser?.();
     if (!user || (user.role !== 'super_admin' && user.role !== 'operations_admin')) {
         showToast('Only Operations Admin and Super Admin can create projects', 'error');
         return;
     }
     ```

  IMPORTANT: Keep the existing `canEditTab('projects')` checks for edit/delete operations (saveEdit, deleteProject, toggleProjectActive, editProject). Those should remain as-is. The new role guard is ONLY for project creation (render button, toggleAddProjectForm, addProject).

  NOTE: Firestore Security Rules already enforce this server-side (firestore.rules line 119: `allow create: if hasRole(['super_admin', 'operations_admin'])`). The client-side check is for UX -- hiding the button and showing a friendly error message.
  </action>
  <verify>
  1. Log in as a finance or procurement user -- the "Add Project" button should NOT be visible.
  2. Log in as an operations_user -- the "Add Project" button should NOT be visible.
  3. Log in as operations_admin or super_admin -- the "Add Project" button should be visible and functional.
  4. Edit/Delete/Deactivate buttons should still follow the existing canEditTab permission (unchanged).
  </verify>
  <done>
  - Add Project button only visible for super_admin and operations_admin roles
  - toggleAddProjectForm() and addProject() have role guards with descriptive error toasts
  - Edit/Delete/Deactivate permissions unchanged (still use canEditTab)
  </done>
</task>

<task type="auto">
  <name>Task 2: Transform personnel field to user datalist with validation in projects.js</name>
  <files>app/views/projects.js</files>
  <action>
  Replace the freetext personnel field in the Add/Edit Project form with an HTML5 datalist populated from the active users collection.

  **Personnel field migration strategy -- IMPORTANT:**
  - New projects: Store `personnel_user_id` and `personnel_name`. Do NOT write the legacy `personnel` field.
  - Editing existing projects: When a user selects from the datalist, write `personnel_user_id` and `personnel_name`. When freetext that does not match a user is entered, write the legacy `personnel` field (backward compat). When the field is cleared, null out ALL three fields (`personnel`, `personnel_user_id`, `personnel_name`).
  - Reading/displaying: Always prefer `personnel_name` over `personnel` for display (fall back to `personnel` for legacy data).

  **Module-level state additions** (near line 15, after existing state vars):
  ```javascript
  let usersData = [];  // Active users for personnel datalist
  ```

  **In render() function** -- Replace the personnel form group (lines ~146-149):
  From:
  ```html
  <div class="form-group">
      <label>Personnel (Optional)</label>
      <input type="text" id="personnel" placeholder="John Doe, Jane Smith">
      <small class="form-hint">Freetext field for personnel assignment.</small>
  </div>
  ```
  To:
  ```html
  <div class="form-group">
      <label>Personnel *</label>
      <input type="text" id="personnel" list="personnelUsersList" placeholder="Type name or email to search..." required autocomplete="off">
      <datalist id="personnelUsersList"></datalist>
      <small class="form-hint">Select an active user from the list. Required for new projects.</small>
  </div>
  ```
  Note: `autocomplete="off"` prevents browser autofill from conflicting with the datalist.

  **In init() function** -- Add users listener (after loadClients() call, before or after loadProjects()):
  ```javascript
  await loadActiveUsers();
  ```

  **New function loadActiveUsers():**
  ```javascript
  async function loadActiveUsers() {
      try {
          const usersQuery = query(
              collection(db, 'users'),
              where('status', '==', 'active')
          );

          const listener = onSnapshot(usersQuery, (snapshot) => {
              usersData = [];
              snapshot.forEach(doc => {
                  const data = doc.data();
                  usersData.push({
                      id: doc.id,
                      full_name: data.full_name || '',
                      email: data.email || ''
                  });
              });
              usersData.sort((a, b) => a.full_name.localeCompare(b.full_name));
              populatePersonnelDatalist();
              console.log('[Projects] Active users loaded:', usersData.length);
          });

          listeners.push(listener);
      } catch (error) {
          console.error('[Projects] Error loading users:', error);
      }
  }
  ```

  **New function populatePersonnelDatalist():**
  ```javascript
  function populatePersonnelDatalist() {
      const datalist = document.getElementById('personnelUsersList');
      if (!datalist) return;

      datalist.innerHTML = usersData.map(user =>
          `<option value="${user.full_name}" data-user-id="${user.id}">${user.full_name} (${user.email})</option>`
      ).join('');
  }
  ```
  NOTE: Use `user.full_name` as the value (not email) because this is what users will see and select. The datalist shows `full_name (email)` as the label for disambiguation.

  **New validation function validatePersonnelSelection():**
  ```javascript
  function validatePersonnelSelection() {
      const personnelInput = document.getElementById('personnel');
      const selectedValue = personnelInput?.value?.trim();

      if (!selectedValue) {
          showToast('Personnel field is required', 'error');
          return null;
      }

      // Find matching user by full_name or email
      const selectedUser = usersData.find(u =>
          u.full_name === selectedValue || u.email === selectedValue
      );

      if (!selectedUser) {
          showToast('Please select a valid user from the dropdown list', 'error');
          personnelInput.focus();
          return null;
      }

      return selectedUser;
  }
  ```

  **Modify addProject() function** -- Replace personnel handling:
  1. Remove the line: `const personnel = document.getElementById('personnel').value.trim();`
  2. Add validation call AFTER other validation (after the status validation blocks, before showLoading):
     ```javascript
     // Validate personnel selection
     const selectedPersonnel = validatePersonnelSelection();
     if (!selectedPersonnel) return;
     ```
  3. In the addDoc call, replace `personnel: personnel || null` with:
     ```javascript
     personnel_user_id: selectedPersonnel.id,
     personnel_name: selectedPersonnel.full_name,
     ```
     Do NOT include a `personnel` field for new projects. New projects use only the new fields.

  **Modify saveEdit() function** -- Apply migrate-on-edit strategy:
  1. Replace the line `const personnel = document.getElementById('personnel').value.trim();` with:
     ```javascript
     const personnelInput = document.getElementById('personnel');
     const personnelValue = personnelInput?.value?.trim() || '';
     let personnelUpdate = {};

     if (personnelValue) {
         // Try to match to a real user from the datalist
         const selectedUser = usersData.find(u =>
             u.full_name === personnelValue || u.email === personnelValue
         );
         if (selectedUser) {
             // Migrate to new format: store user ID and name
             personnelUpdate = {
                 personnel_user_id: selectedUser.id,
                 personnel_name: selectedUser.full_name,
                 personnel: null  // Clear legacy field when migrating to new format
             };
         } else {
             // Freetext fallback: user typed something not in the datalist
             // Keep in legacy field only (do not write personnel_user_id)
             personnelUpdate = {
                 personnel: personnelValue,
                 personnel_user_id: null,
                 personnel_name: null
             };
         }
     } else {
         // Field cleared: null out ALL personnel fields
         personnelUpdate = { personnel: null, personnel_user_id: null, personnel_name: null };
     }
     ```
  2. In the updateDoc call, replace `personnel: personnel || null` with spread: `...personnelUpdate`

  **Modify editProject() function** -- Populate personnel field correctly for editing:
  Replace `document.getElementById('personnel').value = project.personnel || '';` with:
  ```javascript
  document.getElementById('personnel').value = project.personnel_name || project.personnel || '';
  ```

  **Modify toggleAddProjectForm() function** -- Ensure datalist is populated when form opens:
  After clearing the form fields (line ~385-386), add:
  ```javascript
  populatePersonnelDatalist();
  ```

  **Modify destroy() function** -- Clear usersData:
  Add `usersData = [];` alongside the other state resets.

  NOTE on code duplication: `loadActiveUsers()` and `populatePersonnelDatalist()` will be duplicated between projects.js and project-detail.js (Task 3). This is intentional for this phase -- each view manages its own listener lifecycle. Extracting to a shared module can be done in a future refactor if more views need this pattern.
  </action>
  <verify>
  1. Log in as super_admin, go to Projects, click "Add Project".
  2. Click on the Personnel field and start typing -- a dropdown should appear with matching active users.
  3. Try to submit without selecting personnel -- should show "Personnel field is required" error.
  4. Type something that is NOT a valid user and submit -- should show "Please select a valid user" error.
  5. Select a valid user and submit -- project should be created with personnel_user_id and personnel_name fields in Firestore (NO legacy `personnel` field).
  6. Edit an existing project that has old freetext `personnel` -- the field should show the old value. If you select a datalist user and save, Firestore should now have `personnel_user_id`, `personnel_name`, and `personnel: null`.
  7. Edit an existing project, type freetext that does NOT match a user, save -- Firestore should have `personnel` set, `personnel_user_id: null`, `personnel_name: null`.
  8. Check Firestore for the new project -- verify personnel_user_id contains a uid and personnel_name contains the full_name.
  </verify>
  <done>
  - Personnel field uses HTML5 datalist populated from active users via onSnapshot
  - Personnel is required for new project creation (validated against user list)
  - New projects store personnel_user_id and personnel_name only (no legacy `personnel` field)
  - Editing existing projects: datalist match migrates to new format (clears legacy field); freetext keeps legacy field (clears new fields); clearing nulls all three
  - Backward compatible: existing freetext personnel values display correctly via `personnel_name || personnel` fallback
  - Users listener cleaned up in destroy()
  </done>
</task>

<task type="auto">
  <name>Task 3: Add personnel user datalist to project-detail.js inline editing</name>
  <files>app/views/project-detail.js</files>
  <action>
  The project detail page has inline editing for personnel (line ~277). Transform this from a plain text input to a datalist-backed input.

  **PREREQUISITE CHECK:** Before implementing, verify that `saveField` is already async by reading line ~294 of project-detail.js. Confirm the signature is `async function saveField(fieldName, newValue)`. If it is NOT async, add the `async` keyword before `function saveField`. This is critical because the personnel save logic below uses `await updateDoc()` with early returns.

  **Add imports** -- Ensure `query, where` are imported from firebase.js (check existing imports at line ~6). They should already be there.

  **Module-level state** -- Add near the top (after existing state vars around line ~11):
  ```javascript
  let usersData = [];
  let usersListenerUnsub = null;
  ```

  **In init() function** -- Add users listener. After the existing onSnapshot setup for the project, add:
  ```javascript
  // Load active users for personnel datalist
  const usersQuery = query(collection(db, 'users'), where('status', '==', 'active'));
  usersListenerUnsub = onSnapshot(usersQuery, (snapshot) => {
      usersData = [];
      snapshot.forEach(doc => {
          const data = doc.data();
          usersData.push({
              id: doc.id,
              full_name: data.full_name || '',
              email: data.email || ''
          });
      });
      usersData.sort((a, b) => a.full_name.localeCompare(b.full_name));
      populatePersonnelDatalist();
  });
  ```

  **New function populatePersonnelDatalist():**
  ```javascript
  function populatePersonnelDatalist() {
      const datalist = document.getElementById('personnelUsersList');
      if (!datalist) return;
      datalist.innerHTML = usersData.map(user =>
          `<option value="${user.full_name}">${user.full_name} (${user.email})</option>`
      ).join('');
  }
  ```

  **In renderProjectDetail()** -- Modify the personnel input (around line ~277).
  Change from:
  ```html
  <input type="text" data-field="personnel" value="${currentProject.personnel || ''}" onblur="window.saveField('personnel', this.value)" placeholder="(Not set)">
  ```
  To:
  ```html
  <input type="text" data-field="personnel" list="personnelUsersList" value="${currentProject.personnel_name || currentProject.personnel || ''}" onblur="window.saveField('personnel', this.value)" placeholder="Type name to search..." autocomplete="off">
  <datalist id="personnelUsersList"></datalist>
  ```
  Note: Display `personnel_name` first (new field), fall back to `personnel` (legacy freetext).

  Also, after renderProjectDetail() is called and the DOM is updated, call `populatePersonnelDatalist();` at the end of the renderProjectDetail() function body.

  **Modify saveField() function** -- Apply the same migrate-on-edit strategy as projects.js:

  Confirmed: `saveField` is already `async function saveField(fieldName, newValue)` at line ~294.

  Change the personnel case from:
  ```javascript
  } else if (fieldName === 'personnel') {
      valueToSave = newValue.trim() || null;
  ```
  To:
  ```javascript
  } else if (fieldName === 'personnel') {
      const trimmedValue = newValue.trim();
      if (trimmedValue) {
          // Try to match to a real user from the datalist
          const matchedUser = usersData.find(u =>
              u.full_name === trimmedValue || u.email === trimmedValue
          );
          if (matchedUser) {
              // Migrate to new format: store user ID and name, clear legacy field
              try {
                  await updateDoc(doc(db, 'projects', currentProject.id), {
                      personnel_user_id: matchedUser.id,
                      personnel_name: matchedUser.full_name,
                      personnel: null,
                      updated_at: new Date().toISOString()
                  });
                  showToast('Personnel updated', 'success');
              } catch (error) {
                  console.error('[ProjectDetail] Error saving personnel:', error);
                  showToast('Failed to update personnel', 'error');
              }
              return; // Early return -- we handled the save ourselves
          } else {
              // Freetext fallback: keep in legacy field, clear new fields
              try {
                  await updateDoc(doc(db, 'projects', currentProject.id), {
                      personnel: trimmedValue,
                      personnel_user_id: null,
                      personnel_name: null,
                      updated_at: new Date().toISOString()
                  });
                  showToast('Personnel updated', 'success');
              } catch (error) {
                  console.error('[ProjectDetail] Error saving personnel:', error);
                  showToast('Failed to update personnel', 'error');
              }
              return; // Early return
          }
      } else {
          // Field cleared: null out ALL personnel fields
          try {
              await updateDoc(doc(db, 'projects', currentProject.id), {
                  personnel: null,
                  personnel_user_id: null,
                  personnel_name: null,
                  updated_at: new Date().toISOString()
              });
              showToast('Personnel cleared', 'success');
          } catch (error) {
              console.error('[ProjectDetail] Error clearing personnel:', error);
              showToast('Failed to clear personnel', 'error');
          }
          return; // Early return
      }
  ```
  The personnel case now handles ALL its own saving and returns early, so the generic `updateDoc` at the bottom of `saveField` is NOT reached for personnel edits.

  **Modify destroy() function** -- Clean up users listener:
  Add:
  ```javascript
  if (usersListenerUnsub) {
      usersListenerUnsub();
      usersListenerUnsub = null;
  }
  usersData = [];
  ```

  **Label update** -- If the label says "Assigned Personnel", keep it as-is. It correctly describes the field's purpose.
  </action>
  <verify>
  1. Navigate to a project detail page (#/projects/detail/CLMC_XXX_YYYYNNN).
  2. Click on the Personnel field -- a dropdown should appear with active users when typing.
  3. Select a user and blur (click away) -- a toast should say "Personnel updated".
  4. Check Firestore -- the project document should now have `personnel_user_id`, `personnel_name`, and `personnel: null`.
  5. Refresh the page -- the personnel field should show the selected user's name.
  6. Type freetext that does NOT match a user and blur -- Firestore should have `personnel` set, `personnel_user_id: null`, `personnel_name: null`.
  7. Clear the field and blur -- all three personnel fields should be null in Firestore.
  8. Navigate to an existing project with legacy freetext `personnel` -- the field should display the old value correctly.
  9. Navigate away from the detail page and check for console errors about leaked listeners.
  </verify>
  <done>
  - Project detail personnel field uses HTML5 datalist with active users
  - Selecting a valid user stores personnel_user_id and personnel_name, clears legacy `personnel`
  - Freetext fallback stores legacy `personnel`, clears personnel_user_id and personnel_name
  - Clearing the field clears all three personnel fields
  - Backward compatible -- existing freetext personnel displays correctly via `personnel_name || personnel` fallback
  - saveField() confirmed async before adding await-based personnel logic
  - Users listener cleaned up in destroy()
  </done>
</task>

</tasks>

<verification>
1. Log in as finance/procurement user -- "Add Project" button is NOT visible on Projects page
2. Log in as operations_admin or super_admin -- "Add Project" button IS visible
3. Create a new project -- personnel field is required and shows user datalist
4. Submit without selecting personnel -- error toast appears
5. Select a valid user as personnel and submit -- project created with personnel_user_id and personnel_name in Firestore (no legacy `personnel` field)
6. View the new project on the detail page -- personnel shows the selected user's name
7. Edit personnel on detail page by selecting from datalist -- Firestore shows personnel_user_id + personnel_name, legacy `personnel` is null
8. Edit personnel on detail page with freetext -- Firestore shows legacy `personnel`, new fields are null
9. Existing projects with freetext personnel -- still display their old personnel value correctly via fallback
</verification>

<success_criteria>
- Add Project button visible ONLY for super_admin and operations_admin
- toggleAddProjectForm() and addProject() have role guards
- Personnel field is required when creating new projects
- Personnel field uses HTML5 datalist populated from active users (real-time via onSnapshot)
- New projects store personnel_user_id (uid) and personnel_name (denormalized), no legacy `personnel` field
- Editing projects follows migrate-on-edit: datalist match writes new fields + clears legacy; freetext writes legacy + clears new; clearing nulls all three
- Project detail page personnel inline editing uses the same datalist and migration pattern
- Backward compatibility: existing freetext personnel values display correctly via `personnel_name || personnel` fallback
- All users listeners are cleaned up in destroy()
</success_criteria>

<output>
After completion, create `.planning/phases/15-user-data-permission-improvements/15-02-SUMMARY.md`
</output>
