---
phase: 25-project-edit-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/edit-history.js
  - firestore.rules
autonomous: true

must_haves:
  truths:
    - "recordEditHistory function writes to Firestore subcollection without blocking the caller"
    - "showEditHistoryModal function fetches history and displays it using createTimeline"
    - "Firestore security rules allow create but deny update/delete on edit_history subcollection"
  artifacts:
    - path: "app/edit-history.js"
      provides: "Shared edit history module (record + display)"
      exports: ["recordEditHistory", "showEditHistoryModal"]
    - path: "firestore.rules"
      provides: "Security rules for edit_history subcollection"
      contains: "edit_history"
  key_links:
    - from: "app/edit-history.js"
      to: "app/firebase.js"
      via: "import { db, collection, addDoc, getDocs, query, orderBy, doc }"
      pattern: "import.*firebase"
    - from: "app/edit-history.js"
      to: "app/components.js"
      via: "import { createTimeline }"
      pattern: "createTimeline"
    - from: "app/edit-history.js"
      to: "app/utils.js"
      via: "import { formatDate, formatCurrency }"
      pattern: "formatDate|formatCurrency"
---

<objective>
Create the edit history shared module and Firestore security rules for Phase 25.

Purpose: Provides the `recordEditHistory()` function that mutation points will call (Plan 02), and the `showEditHistoryModal()` function for displaying history. Also adds Firestore security rules so the subcollection writes don't fail with permission denied.

Output: `app/edit-history.js` module and updated `firestore.rules`
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-project-edit-history/25-RESEARCH.md
@app/firebase.js
@app/components.js
@app/utils.js
@app/expense-modal.js
@firestore.rules
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create app/edit-history.js shared module</name>
  <files>app/edit-history.js</files>
  <action>
Create a new ES6 module `app/edit-history.js` with these exports:

1. **`recordEditHistory(projectDocId, action, changes)`** - Writes one document to the `projects/{projectDocId}/edit_history` subcollection.
   - Parameters:
     - `projectDocId` (string): The Firestore document ID of the project (NOT the project_code)
     - `action` (string): One of `'create'`, `'update'`, `'toggle_active'`, `'personnel_add'`, `'personnel_remove'`
     - `changes` (array): Array of `{ field, old_value, new_value }` objects
   - Gets current user via `window.getCurrentUser?.()` for attribution (`user_id` from `.uid`, `user_name` from `.full_name`)
   - Document schema:
     ```
     {
       timestamp: new Date().toISOString(),
       user_id: user?.uid || 'unknown',
       user_name: user?.full_name || 'Unknown User',
       action: action,
       changes: changes
     }
     ```
   - Fire-and-forget pattern: catch errors and log to console, never throw. This is non-critical and must not block the primary save operation.
   - Log success: `console.log('[EditHistory] Recorded:', action, changes.length, 'change(s)')`
   - Log failure: `console.error('[EditHistory] Failed to record:', error)`

2. **`showEditHistoryModal(projectDocId, projectCode)`** - Fetches edit history and displays in a modal.
   - Query: `collection(db, 'projects', projectDocId, 'edit_history')` with `orderBy('timestamp', 'desc')`
   - Use `getDocs(q)` (one-time fetch, not real-time listener)
   - Map each history entry to a timeline item:
     - `title`: `"${getActionLabel(entry.action)} by ${entry.user_name}"`
     - `date`: `formatDate(entry.timestamp)`
     - `description`: Each change on its own line using `<br>` separator: `<strong>${formatFieldName(c.field)}</strong>: ${formatValue(c.old_value)} &rarr; ${formatValue(c.new_value)}`
     - `status`: `'completed'` (all history entries are completed events)
   - Render using `createTimeline(timelineItems)` from `app/components.js`
   - If no history entries, show: `<p style="color: #64748b; text-align: center; padding: 2rem 0;">No edit history recorded yet.</p>`
   - Modal follows expense-modal.js pattern:
     - Remove existing `#editHistoryModal` if any
     - Create modal HTML with `class="modal active"`, `max-width: 700px`
     - Modal header: `Edit History: ${projectCode}`
     - Close button calls `window.closeEditHistoryModal()`
     - Insert via `document.body.insertAdjacentHTML('beforeend', modalHTML)`
   - Register `window.closeEditHistoryModal` to remove the modal element
   - Show loading state while fetching (use `showLoading(true/false)`)

3. **Internal helpers** (not exported):
   - `formatFieldName(fieldName)` - Maps internal field names to human-readable labels:
     - `project_name` -> `Project Name`
     - `budget` -> `Budget`
     - `contract_cost` -> `Contract Cost`
     - `internal_status` -> `Internal Status`
     - `project_status` -> `Project Status`
     - `active` -> `Active Status`
     - `personnel` -> `Personnel`
     - `client_code` -> `Client`
     - `client_id` -> `Client`
     - Fallback: return the raw field name
   - `formatValue(value)` - Formats values for display:
     - `null` or `undefined` -> `(empty)`
     - `boolean` true -> `Active`, false -> `Inactive`
     - `number` -> `formatCurrency(value)` from utils.js
     - Everything else -> `String(value)`
   - `getActionLabel(action)` - Maps action types to labels:
     - `create` -> `Project Created`
     - `update` -> `Fields Updated`
     - `toggle_active` -> `Status Changed`
     - `personnel_add` -> `Personnel Added`
     - `personnel_remove` -> `Personnel Removed`
     - Fallback: `'Updated'`

Imports needed from firebase.js: `db, collection, addDoc, getDocs, query, orderBy, doc`
Imports needed from components.js: `createTimeline`
Imports needed from utils.js: `formatDate, formatCurrency, showLoading`
  </action>
  <verify>
Verify file exists and has correct structure:
- File `app/edit-history.js` exists
- Exports `recordEditHistory` and `showEditHistoryModal`
- Imports from firebase.js, components.js, utils.js
- No syntax errors (load in browser console on http://localhost:8000)
  </verify>
  <done>
`app/edit-history.js` exists with `recordEditHistory()` and `showEditHistoryModal()` exported. Internal helpers `formatFieldName`, `formatValue`, `getActionLabel` are defined. Module imports all needed dependencies from firebase.js, components.js, and utils.js.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Firestore security rules for edit_history subcollection</name>
  <files>firestore.rules</files>
  <action>
Add a subcollection rule INSIDE the existing `match /projects/{projectId}` block (between lines 114-126 of firestore.rules).

The new rule goes BEFORE the closing `}` of the projects match block (currently line 126). Add it after the existing project delete rule (line 125):

```
      // edit_history subcollection (Phase 25 - append-only audit trail)
      match /edit_history/{entryId} {
        // Read: all active users (consistent with project read access)
        allow read: if isActiveUser();

        // Create: roles that can update projects (same as project update rule)
        allow create: if hasRole(['super_admin', 'operations_admin', 'finance']);

        // Append-only: no updates or deletes allowed
        allow update: if false;
        allow delete: if false;
      }
```

This rule:
- Allows all active users to READ history (anyone who can view a project can view its history)
- Allows super_admin, operations_admin, and finance to CREATE history entries (same roles that can update projects)
- Denies update and delete (history is immutable/append-only)

IMPORTANT: Firestore does NOT cascade rules from parent to subcollections. Without this explicit rule, all edit_history writes would fail with permission denied.
  </action>
  <verify>
Read `firestore.rules` and confirm:
- `match /edit_history/{entryId}` block exists inside `match /projects/{projectId}`
- `allow read: if isActiveUser()` is present
- `allow create: if hasRole(...)` includes super_admin, operations_admin, finance
- `allow update: if false` and `allow delete: if false` are present
  </verify>
  <done>
`firestore.rules` contains subcollection rules for `edit_history` that allow read for active users, create for project-editing roles, and deny update/delete.
  </done>
</task>

</tasks>

<verification>
1. `app/edit-history.js` exists with correct exports
2. `firestore.rules` has edit_history subcollection rules nested inside projects match block
3. No syntax errors in either file
4. Module correctly imports from firebase.js, components.js, utils.js
</verification>

<success_criteria>
- `app/edit-history.js` exports `recordEditHistory` and `showEditHistoryModal`
- `firestore.rules` has append-only rules for `projects/{projectId}/edit_history/{entryId}`
- Both files have no syntax errors
</success_criteria>

<output>
After completion, create `.planning/phases/25-project-edit-history/25-01-SUMMARY.md`
</output>
