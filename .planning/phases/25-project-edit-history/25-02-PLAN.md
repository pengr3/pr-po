---
phase: 25-project-edit-history
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - app/views/project-detail.js
  - app/views/projects.js
autonomous: false

must_haves:
  truths:
    - "Edit History button appears in Project Information card header"
    - "Clicking Edit History button opens modal showing chronological list of all edits"
    - "Each history entry shows what field changed, old value to new value, timestamp, and user who made the change"
    - "History captures changes from project-detail.js inline editing (saveField, toggleActive, personnel add/remove)"
    - "History captures changes from projects.js (addProject creation, saveEdit bulk update, toggleProjectActive)"
    - "No-op saves (unchanged values) do not create spurious history entries"
    - "History recording does not block or break the primary save operation"
  artifacts:
    - path: "app/views/project-detail.js"
      provides: "Edit History button UI + 4 instrumented mutation points + showEditHistory window function"
      contains: "recordEditHistory"
    - path: "app/views/projects.js"
      provides: "3 instrumented mutation points (addProject, saveEdit, toggleProjectActive)"
      contains: "recordEditHistory"
  key_links:
    - from: "app/views/project-detail.js"
      to: "app/edit-history.js"
      via: "import { recordEditHistory, showEditHistoryModal }"
      pattern: "import.*edit-history"
    - from: "app/views/projects.js"
      to: "app/edit-history.js"
      via: "import { recordEditHistory }"
      pattern: "import.*edit-history"
    - from: "project-detail.js button onclick"
      to: "showEditHistoryModal"
      via: "window.showEditHistory"
      pattern: "window\\.showEditHistory"
---

<objective>
Wire edit history recording into all 7 mutation points across project-detail.js and projects.js, and add the Edit History button to the Project Detail UI.

Purpose: This plan connects the edit-history.js module (from Plan 01) to every place where project data changes, so all edits are tracked. It also adds the UI button and window function to view history.

Output: Fully instrumented project mutation points + visible Edit History button on Project Detail page
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-project-edit-history/25-RESEARCH.md
@.planning/phases/25-project-edit-history/25-01-SUMMARY.md
@app/edit-history.js
@app/views/project-detail.js
@app/views/projects.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Edit History button and instrument project-detail.js mutations</name>
  <files>app/views/project-detail.js</files>
  <action>
**Import:** Add to the existing imports at top of file:
```javascript
import { recordEditHistory, showEditHistoryModal } from '../edit-history.js';
```

**UI Button:** In the `renderProjectDetail()` function, modify the Project Information card header (currently around line 286-289). Change the header `<div>` to use flexbox layout with the button right-aligned:

```html
<div style="border-bottom: 1px solid #e5e7eb; padding-bottom: 0.75rem; margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: flex-start;">
    <div>
        <h3 style="margin: 0 0 0.25rem 0; font-size: 1.125rem; font-weight: 600;">Project Information</h3>
        <p style="color: #94a3b8; font-size: 0.875rem; margin: 0;">Created: ${formatDate(currentProject.created_at)}${currentProject.updated_at ? ' | Updated: ' + formatDate(currentProject.updated_at) : ''}</p>
    </div>
    <button class="btn btn-sm btn-secondary" onclick="window.showEditHistory()" style="white-space: nowrap; padding: 0.4rem 0.75rem; font-size: 0.8rem;">
        Edit History
    </button>
</div>
```

The button is visible to ALL users with project view access (no permission guard needed -- viewing history is read-only).

**Window function:** In `attachWindowFunctions()` (line 742), add:
```javascript
window.showEditHistory = () => currentProject && showEditHistoryModal(currentProject.id, currentProject.project_code);
```

**Instrument saveField() (line 561):**
After the value preparation (line 596), BEFORE the try block (line 598), add a no-op check:
```javascript
// Skip if no actual change (avoids spurious history entries and unnecessary writes)
const oldValue = currentProject[fieldName];
const normalizedOld = (fieldName === 'budget' || fieldName === 'contract_cost')
    ? (oldValue != null ? parseFloat(oldValue) : null)
    : oldValue;
if (normalizedOld === valueToSave) {
    console.log('[ProjectDetail] No change for', fieldName);
    return true;
}
```

Then AFTER the successful `updateDoc` call (line 600-603), before the `console.log('[ProjectDetail] Saved'` line, add fire-and-forget history recording:
```javascript
// Record edit history (fire-and-forget)
recordEditHistory(currentProject.id, 'update', [
    { field: fieldName, old_value: oldValue ?? null, new_value: valueToSave }
]).catch(err => console.error('[EditHistory] saveField failed:', err));
```

**Instrument toggleActive() (line 664):**
AFTER the successful `updateDoc` call (line 679-682), before the `showToast` line, add:
```javascript
// Record edit history (fire-and-forget)
recordEditHistory(currentProject.id, 'toggle_active', [
    { field: 'active', old_value: !newValue, new_value: newValue }
]).catch(err => console.error('[EditHistory] toggleActive failed:', err));
```

**Instrument selectDetailPersonnel() (line 484):**
AFTER the successful `updateDoc` call (line 495-502), before the `console.log('[ProjectDetail] Personnel added:')` line, add:
```javascript
// Record edit history (fire-and-forget)
recordEditHistory(currentProject.id, 'personnel_add', [
    { field: 'personnel', old_value: null, new_value: userName }
]).catch(err => console.error('[EditHistory] selectPersonnel failed:', err));
```

**Instrument removeDetailPersonnel() (line 525):**
AFTER the successful `updateDoc` call (line 538-545), before the `console.log('[ProjectDetail] Personnel removed:')` line, add:
```javascript
// Record edit history (fire-and-forget)
recordEditHistory(currentProject.id, 'personnel_remove', [
    { field: 'personnel', old_value: userName || userId, new_value: null }
]).catch(err => console.error('[EditHistory] removePersonnel failed:', err));
```

**IMPORTANT:** All `recordEditHistory` calls use `.catch()` fire-and-forget pattern. They must NEVER be `await`ed in the main flow. The primary save must succeed regardless of history recording.

**IMPORTANT:** For `removeDetailPersonnel`, use the `userName` parameter (which is the display name of the removed person). If `userName` is falsy, fall back to `userId`.
  </action>
  <verify>
1. Open http://localhost:8000 and navigate to a project detail page
2. Verify "Edit History" button appears in the Project Information card header, right-aligned
3. Click "Edit History" button -- modal should open showing "No edit history recorded yet"
4. Change a field (e.g., budget) and blur -- check browser console for `[EditHistory] Recorded: update, 1 change(s)`
5. Click "Edit History" again -- should show the change entry with field name, old/new values, timestamp, your name
6. Blur a field WITHOUT changing its value -- console should show `[ProjectDetail] No change for fieldName` (no history entry)
7. Toggle active status -- check console for `[EditHistory] Recorded: toggle_active`
8. Add a personnel member -- check console for `[EditHistory] Recorded: personnel_add`
9. Remove a personnel member -- check console for `[EditHistory] Recorded: personnel_remove`
  </verify>
  <done>
project-detail.js has: (1) Edit History button in Project Information card header, right-aligned; (2) window.showEditHistory function calling showEditHistoryModal; (3) All 4 mutation points instrumented with fire-and-forget recordEditHistory calls; (4) No-op check in saveField prevents spurious history entries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Instrument projects.js mutation points</name>
  <files>app/views/projects.js</files>
  <action>
**Import:** Add to the existing imports at top of file (line 6):
```javascript
import { recordEditHistory } from '../edit-history.js';
```

**Instrument addProject() (line 582):**
The `addDoc` call (line 648) returns a document reference. Capture it, then record a 'create' history entry.

Change:
```javascript
await addDoc(collection(db, 'projects'), { ... });
```
To:
```javascript
const docRef = await addDoc(collection(db, 'projects'), { ... });
```

Then AFTER the addDoc call and BEFORE the syncPersonnelToAssignments call, add:
```javascript
// Record creation in edit history (fire-and-forget)
recordEditHistory(docRef.id, 'create', [
    { field: 'project_name', old_value: null, new_value: project_name },
    { field: 'client', old_value: null, new_value: clientCode },
    { field: 'internal_status', old_value: null, new_value: internal_status },
    { field: 'project_status', old_value: null, new_value: project_status },
    ...(budget ? [{ field: 'budget', old_value: null, new_value: budget }] : []),
    ...(contract_cost ? [{ field: 'contract_cost', old_value: null, new_value: contract_cost }] : []),
    ...(selectedPersonnel.length > 0 ? [{ field: 'personnel', old_value: null, new_value: selectedPersonnel.map(u => u.name).join(', ') }] : [])
]).catch(err => console.error('[EditHistory] addProject failed:', err));
```

**Instrument saveEdit() (line 934):**
The `existingProject` variable is already captured at line 993 (`allProjects.find(...)`). Use it for diffing.

AFTER the successful `updateDoc` call (line 1001-1011), BEFORE the syncPersonnelToAssignments call (line 1014), add:
```javascript
// Build diff for edit history
const editChanges = [];
if (existingProject.project_name !== project_name) {
    editChanges.push({ field: 'project_name', old_value: existingProject.project_name, new_value: project_name });
}
if (existingProject.client_code !== clientCode) {
    editChanges.push({ field: 'client_code', old_value: existingProject.client_code, new_value: clientCode });
}
if (existingProject.internal_status !== internal_status) {
    editChanges.push({ field: 'internal_status', old_value: existingProject.internal_status, new_value: internal_status });
}
if (existingProject.project_status !== project_status) {
    editChanges.push({ field: 'project_status', old_value: existingProject.project_status, new_value: project_status });
}
const oldBudget = existingProject.budget != null ? parseFloat(existingProject.budget) : null;
if (oldBudget !== budget) {
    editChanges.push({ field: 'budget', old_value: oldBudget, new_value: budget });
}
const oldContract = existingProject.contract_cost != null ? parseFloat(existingProject.contract_cost) : null;
if (oldContract !== contract_cost) {
    editChanges.push({ field: 'contract_cost', old_value: oldContract, new_value: contract_cost });
}
// Check personnel changes
const oldPersonnelNames = (existingProject.personnel_names || []).sort().join(',');
const newPersonnelNames = selectedPersonnel.map(u => u.name).sort().join(',');
if (oldPersonnelNames !== newPersonnelNames) {
    editChanges.push({
        field: 'personnel',
        old_value: existingProject.personnel_names?.join(', ') || '(none)',
        new_value: selectedPersonnel.map(u => u.name).join(', ') || '(none)'
    });
}
// Only record if something actually changed
if (editChanges.length > 0) {
    recordEditHistory(editingProject, 'update', editChanges)
        .catch(err => console.error('[EditHistory] saveEdit failed:', err));
}
```

**Instrument toggleProjectActive() (line 1056):**
AFTER the successful `updateDoc` call (line 1070-1073), BEFORE the `showToast` call (line 1075), add:
```javascript
// Record edit history (fire-and-forget)
recordEditHistory(projectId, 'toggle_active', [
    { field: 'active', old_value: currentStatus, new_value: !currentStatus }
]).catch(err => console.error('[EditHistory] toggleProjectActive failed:', err));
```

Note: `currentStatus` is the boolean parameter passed to the function, and `!currentStatus` is the new value (already used in the updateDoc call).

**IMPORTANT:** All calls are fire-and-forget with `.catch()`. Never `await` them in the main flow.
  </action>
  <verify>
1. Open http://localhost:8000, navigate to Projects tab
2. Create a new project -- check browser console for `[EditHistory] Recorded: create`
3. Navigate to the new project's detail page, click "Edit History" -- should show "Project Created" entry with all initial field values
4. Go back to Projects tab, click edit on a project, change the name and save -- console shows `[EditHistory] Recorded: update`
5. Toggle a project's active status from the Projects list -- console shows `[EditHistory] Recorded: toggle_active`
6. Edit a project but don't change any values, save -- no history entry should be recorded (editChanges array empty)
  </verify>
  <done>
projects.js has all 3 mutation points instrumented: (1) addProject records 'create' with all initial field values; (2) saveEdit diffs old vs new and only records actual changes; (3) toggleProjectActive records active status toggle. All calls are fire-and-forget.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete project edit history feature: Edit History button on Project Detail page, edit history recording on all 7 mutation points across project-detail.js and projects.js, timeline modal display using existing createTimeline component, and Firestore security rules for the edit_history subcollection.</what-built>
  <how-to-verify>
1. Navigate to any existing project's detail page
2. Verify "Edit History" button appears in the Project Information card header, right-aligned next to "Project Information" title
3. Click "Edit History" -- modal opens showing "No edit history recorded yet" (for existing projects with no prior edits)
4. Close the modal
5. Change the project name -- blur the field
6. Click "Edit History" again -- should show one entry: "Fields Updated by [Your Name]" with "Project Name: [old] -> [new]" and timestamp
7. Change the budget field -- "Edit History" should now show 2 entries (newest first)
8. Toggle the Active/Inactive badge -- "Edit History" shows "Status Changed" entry
9. Add a personnel member via the dropdown -- "Edit History" shows "Personnel Added" entry
10. Remove a personnel member -- "Edit History" shows "Personnel Removed" entry
11. Navigate to Projects list, create a new project, then view its detail page -- "Edit History" shows "Project Created" entry with all initial values
12. Edit a project from the Projects list view (edit button) -- changes appear in that project's Edit History
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `app/views/project-detail.js` imports from `edit-history.js` and has 4 instrumented mutation points
2. `app/views/projects.js` imports from `edit-history.js` and has 3 instrumented mutation points
3. Edit History button is visible in Project Information card header
4. Clicking button opens modal with timeline of changes
5. All 7 mutation types produce correct history entries
6. No-op saves do not create history entries
7. History recording never blocks or breaks primary save operations
8. Empty history shows friendly "No edit history recorded yet" message
</verification>

<success_criteria>
- Edit History button visible on Project Detail page, right-aligned in Project Information card header
- All 7 mutation points record history entries with correct field names, old/new values, timestamps, and user attribution
- Timeline modal displays entries in reverse chronological order using createTimeline component
- No-op changes (blurring without editing) do not create spurious entries
- History recording failures do not affect primary save operations
- Projects with no history show "No edit history recorded yet"
</success_criteria>

<output>
After completion, create `.planning/phases/25-project-edit-history/25-02-SUMMARY.md`
</output>
