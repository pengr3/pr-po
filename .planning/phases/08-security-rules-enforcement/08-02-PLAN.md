---
phase: 08-security-rules-enforcement
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - firestore.rules
autonomous: true

must_haves:
  truths:
    - "Unauthenticated users cannot read or write any collection"
    - "Pending users cannot access data (except their own user doc and invitation_codes)"
    - "Active users can only access collections permitted by their role"
    - "operations_user can only list MRFs/PRs/POs/TRs for assigned projects (or legacy data)"
    - "operations_admin can only read/update operations_user documents (scoped to ops tier)"
    - "User self-create enforces pending status (prevents self-promotion)"
  artifacts:
    - path: "firestore.rules"
      provides: "Server-side access control for all 9 collections"
      min_lines: 150
      contains: "isActiveUser"
  key_links:
    - from: "firestore.rules"
      to: "users collection"
      via: "get() helper function"
      pattern: "get\\(/databases/\\$\\(database\\)/documents/users/"
---

<objective>
Write complete Firestore Security Rules enforcing user status, role permissions, and project assignments

Purpose: Close the security gap where client-side permission checks (Phases 5-7) can be bypassed via browser DevTools. Security Rules are the hard boundary.
Output: firestore.rules with rules for all 9 collections (users, role_templates, invitation_codes, projects, mrfs, prs, pos, transport_requests, suppliers, deleted_mrfs)
</objective>

<execution_context>
@C:\Users\Admin\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Admin\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-security-rules-enforcement/08-CONTEXT.md
@.planning/phases/08-security-rules-enforcement/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Firestore Security Rules with helper functions</name>
  <files>firestore.rules</files>
  <action>
Create firestore.rules at repo root following the skeleton from RESEARCH.md with these LOCKED modifications from CONTEXT.md:

**Helper functions (at top of rules file):**
- `isSignedIn()`: `request.auth != null`
- `getUserData()`: `get(/databases/$(database)/documents/users/$(request.auth.uid)).data`
- `isActiveUser()`: `isSignedIn() && getUserData().status == 'active'`
- `hasRole(roles)`: `isActiveUser() && getUserData().role in roles`
- `isRole(role)`: `hasRole([role])`
- `isAssignedToProject(projectCode)`: `getUserData().all_projects == true || projectCode in getUserData().assigned_project_codes`
- `isLegacyOrAssigned(projectCode)`: Helper for project-scoped collections - checks if doc has no project_code, empty project_code, or user is assigned

**Collection rules (per CONTEXT.md locked decisions):**

**users collection:**
- get: own doc OR super_admin OR (operations_admin AND target role is operations_user)
- list: super_admin OR (operations_admin with filter for operations_user only)
- create: signed-in user creating own doc AND request.resource.data.status == 'pending'
- update: super_admin OR (operations_admin AND target role is operations_user) OR own doc
- delete: false

**role_templates collection:**
- read: isActiveUser()
- write: isRole('super_admin')

**invitation_codes collection:**
- read: isSignedIn() (not isActiveUser - registration validation needs this)
- create: isRole('super_admin')
- update: isSignedIn() (not isActiveUser - registration marks code used while pending)
- delete: false

**projects collection:**
- read: isActiveUser()
- create: hasRole(['super_admin', 'operations_admin'])
- update: hasRole(['super_admin', 'operations_admin', 'finance'])
- delete: hasRole(['super_admin', 'operations_admin'])

**mrfs collection:**
- get: isActiveUser()
- list: isActiveUser() AND (non-operations_user roles OR operations_user with legacy/assigned check)
- create: hasRole(['super_admin', 'operations_admin', 'operations_user', 'procurement'])
- update: hasRole(['super_admin', 'operations_admin', 'procurement'])
- delete: hasRole(['super_admin', 'operations_admin'])

**prs collection:**
- get: isActiveUser()
- list: same pattern as mrfs (operations_user is project-scoped)
- create: hasRole(['super_admin', 'operations_admin', 'procurement'])
- update: hasRole(['super_admin', 'operations_admin', 'finance', 'procurement'])
- delete: hasRole(['super_admin', 'operations_admin', 'procurement'])

**pos collection:**
- get: isActiveUser()
- list: same pattern as mrfs (operations_user is project-scoped)
- create: hasRole(['super_admin', 'finance'])
- update: hasRole(['super_admin', 'finance', 'procurement'])
- delete: hasRole(['super_admin'])

**transport_requests collection:**
- get: isActiveUser()
- list: same pattern as mrfs (operations_user is project-scoped)
- create: hasRole(['super_admin', 'operations_admin', 'operations_user', 'procurement'])
- update: hasRole(['super_admin', 'operations_admin', 'finance', 'procurement'])
- delete: hasRole(['super_admin', 'operations_admin', 'procurement'])

**suppliers collection:**
- read: isActiveUser()
- create/update/delete: hasRole(['super_admin', 'procurement'])

**deleted_mrfs collection:**
- read: hasRole(['super_admin', 'operations_admin'])
- create: hasRole(['super_admin', 'operations_admin'])
- update: false
- delete: false

**Critical implementation details:**
1. operations_admin scoping: For users collection, operations_admin can ONLY read/update docs where `resource.data.role == 'operations_user'` (CONTEXT.md locked)
2. Self-promotion prevention: users create rule MUST validate `request.resource.data.status == 'pending'`
3. Legacy data: `!('project_code' in resource.data) || resource.data.project_code == ''` means visible to all
4. Short-circuit: Always put isSignedIn() first to avoid get() on unauthenticated requests
  </action>
  <verify>
Syntax validation (requires Firebase CLI installed globally):
```bash
# If firebase CLI available:
firebase deploy --only firestore:rules --dry-run 2>&1 | head -20

# Manual syntax check - look for parse errors in output
```

File structure check:
- File exists: `ls firestore.rules`
- Contains helper functions: `grep -c "function isActiveUser" firestore.rules`
- Contains all 9 collections: `grep -c "match /" firestore.rules` (should be 10: 1 root + 9 collections)
  </verify>
  <done>
- firestore.rules exists at repo root
- Contains helper functions: isSignedIn, getUserData, isActiveUser, hasRole, isRole, isAssignedToProject
- Contains rules for all 9 collections + deleted_mrfs
- operations_admin scoped to operations_user docs only
- User self-create enforces pending status
- Legacy data handling included for project-scoped collections
  </done>
</task>

</tasks>

<verification>
Rules file completeness check:
```bash
# File exists and has content
wc -l firestore.rules  # Expect 150+ lines

# Helper functions present
grep "function isSignedIn" firestore.rules
grep "function getUserData" firestore.rules
grep "function isActiveUser" firestore.rules
grep "function hasRole" firestore.rules
grep "function isAssignedToProject" firestore.rules

# All collections have rules
grep "match /users/" firestore.rules
grep "match /role_templates/" firestore.rules
grep "match /invitation_codes/" firestore.rules
grep "match /projects/" firestore.rules
grep "match /mrfs/" firestore.rules
grep "match /prs/" firestore.rules
grep "match /pos/" firestore.rules
grep "match /transport_requests/" firestore.rules
grep "match /suppliers/" firestore.rules
grep "match /deleted_mrfs/" firestore.rules

# Key security patterns
grep "status == 'pending'" firestore.rules  # Self-promotion prevention
grep "operations_user" firestore.rules      # ops_admin scoping
grep "project_code" firestore.rules         # Legacy data handling
```
</verification>

<success_criteria>
- [ ] firestore.rules exists at repo root with 150+ lines
- [ ] Helper functions defined: isSignedIn, getUserData, isActiveUser, hasRole, isRole, isAssignedToProject
- [ ] All 9 collections have explicit rules
- [ ] users collection: operations_admin scoped to operations_user docs only
- [ ] users collection: create enforces status == 'pending'
- [ ] invitation_codes: update allows isSignedIn() (not isActiveUser)
- [ ] mrfs/prs/pos/transport_requests: operations_user list is project-scoped with legacy data handling
</success_criteria>

<output>
After completion, create `.planning/phases/08-security-rules-enforcement/08-02-SUMMARY.md`
</output>
