---
phase: 07-project-assignment-system
plan: 04
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - app/views/mrf-form.js
  - app/views/procurement.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "MRF form project dropdown shows only assigned active projects for operations_user"
    - "MRF form project dropdown shows all active projects for other roles"
    - "MRF form shows a hint message when operations_user has zero assigned projects"
    - "MRF form project dropdown re-populates when assignments change (no reload)"
    - "Procurement MRF list shows only MRFs belonging to assigned projects for operations_user"
    - "Procurement MRF list shows all MRFs for other roles"
    - "Legacy MRFs without project_code are always shown to operations_user"
    - "Procurement MRF list re-filters when assignments change (no reload)"
    - "Only the mrfs tab in procurement is filtered -- supplier, PR/TR, PO tabs are untouched"
  artifacts:
    - path: "app/views/mrf-form.js"
      provides: "MRF form with assignment-scoped project dropdown"
      contains: "getAssignedProjectCodes"
    - path: "app/views/procurement.js"
      provides: "Procurement MRF list with assignment-scoped filtering"
      contains: "getAssignedProjectCodes"
  key_links:
    - from: "app/views/mrf-form.js (loadProjects onSnapshot callback)"
      to: "getAssignedProjectCodes()"
      via: "filter projects array after sorting, before populating dropdown"
      pattern: "getAssignedProjectCodes"
    - from: "app/views/mrf-form.js (init)"
      to: "assignmentsChanged event"
      via: "window.addEventListener, re-runs populateProjectDropdown"
      pattern: "addEventListener.*assignmentsChanged"
    - from: "app/views/procurement.js (loadMRFs onSnapshot callback)"
      to: "getAssignedProjectCodes()"
      via: "filter allMRFs after collection, before material/transport split"
      pattern: "getAssignedProjectCodes"
    - from: "app/views/procurement.js (init)"
      to: "assignmentsChanged event"
      via: "window.addEventListener, re-runs MRF filter and re-render"
      pattern: "addEventListener.*assignmentsChanged"
---

<objective>
Add assignment-based filtering to the MRF form project dropdown and the procurement MRF list.

Purpose: An Operations User creating an MRF should only see their assigned projects in the dropdown. An Operations User viewing the MRF list in procurement should only see MRFs for their assigned projects. Both views react to assignmentsChanged in real time. No other tabs in procurement are touched -- the CONTEXT.md constraint is explicit that PR/TR generation, PO tracking, and supplier tabs remain unfiltered.

Output: mrf-form.js filters the project dropdown after loading from Firestore. procurement.js filters the MRF list after loading from Firestore. Both subscribe to assignmentsChanged and re-filter on fire.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-project-assignment-system/07-RESEARCH.md
@.planning/phases/07-project-assignment-system/07-01-SUMMARY.md
@app/views/mrf-form.js
@app/views/procurement.js
@app/utils.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add assignment filter to mrf-form.js project dropdown</name>
  <files>app/views/mrf-form.js</files>
  <action>
Three changes to mrf-form.js. All are additive.

**Change A: Extract the dropdown population into a reusable function**

The current loadProjects() function (starting at line 244) sets up an onSnapshot listener. Inside the callback (lines 252-286), it collects projects, sorts them, and populates the dropdown in a single linear block. We need to be able to re-run the population logic when assignments change (without re-running the Firestore query). To do this cleanly, extract the population logic into a separate function.

Add a module-level variable to hold the snapshot data:
```javascript
let cachedProjects = [];   // Holds the latest projects from the onSnapshot callback
```
Place this at the top of the file alongside the existing `let projectsListener = null;` (after line 10).

Then modify the onSnapshot callback (lines 252-286). The current callback body is:
```javascript
        projectsListener = onSnapshot(q, (snapshot) => {
            // Clear existing options
            projectSelect.innerHTML = '<option value="">-- Select a project --</option>';

            if (snapshot.empty) {
                projectSelect.innerHTML = '<option value="">No projects available</option>';
                return;
            }

            // Collect and sort projects
            const projects = [];
            snapshot.forEach(doc => {
                projects.push({ id: doc.id, ...doc.data() });
            });

            // Sort by created_at descending (most recent first)
            projects.sort((a, b) => {
                const aTime = a.created_at ? new Date(a.created_at).getTime() : 0;
                const bTime = b.created_at ? new Date(b.created_at).getTime() : 0;
                return bTime - aTime;
            });

            // Add sorted project options
            projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project.project_code;
                option.textContent = `${project.project_code} - ${project.project_name}`;
                option.dataset.projectName = project.project_name;
                projectSelect.appendChild(option);
            });
        }, (error) => { ... });
```

Replace the callback body with:
```javascript
        projectsListener = onSnapshot(q, (snapshot) => {
            // Cache projects for re-population on assignment change
            cachedProjects = [];
            snapshot.forEach(doc => {
                cachedProjects.push({ id: doc.id, ...doc.data() });
            });

            // Sort by created_at descending (most recent first)
            cachedProjects.sort((a, b) => {
                const aTime = a.created_at ? new Date(a.created_at).getTime() : 0;
                const bTime = b.created_at ? new Date(b.created_at).getTime() : 0;
                return bTime - aTime;
            });

            populateProjectDropdown();
        }, (error) => { ... });
```

The error callback at the end of onSnapshot stays exactly as it is.

**Change B: Add populateProjectDropdown() function**

Add this function after loadProjects() (before generateMRFId or any other function):

```javascript
/**
 * Populate the project dropdown from cachedProjects, applying assignment filter
 * for operations_user. Called by the onSnapshot callback and by the
 * assignmentsChanged event handler.
 */
function populateProjectDropdown() {
    const projectSelect = document.getElementById('projectName');
    if (!projectSelect) return;

    // Phase 7: Filter to assigned projects for operations_user
    const assignedCodes = window.getAssignedProjectCodes?.();
    let projects = cachedProjects;
    if (assignedCodes !== null) {
        projects = cachedProjects.filter(p => assignedCodes.includes(p.project_code));
    }

    // Clear and rebuild dropdown
    projectSelect.innerHTML = '<option value="">-- Select a project --</option>';

    if (projects.length === 0) {
        // Distinct hint for operations_user with zero assignments vs truly empty collection
        if (assignedCodes !== null) {
            projectSelect.innerHTML = '<option value="" disabled>No projects assigned -- contact your admin</option>';
        } else {
            projectSelect.innerHTML = '<option value="">No projects available</option>';
        }
        return;
    }

    projects.forEach(project => {
        const option = document.createElement('option');
        option.value = project.project_code;
        option.textContent = `${project.project_code} - ${project.project_name}`;
        option.dataset.projectName = project.project_name;
        projectSelect.appendChild(option);
    });
}
```

**Change C: Subscribe to assignmentsChanged in init() and clean up in destroy()**

In init() (line 218), after the `loadProjects()` call (line 229) and before the form submit handler setup (line 232), add:

```javascript
        // Phase 7: Re-populate dropdown when assignments change
        const assignmentChangeHandler = () => {
            console.log('[MRFForm] Assignments changed, re-populating project dropdown...');
            populateProjectDropdown();
        };
        window.addEventListener('assignmentsChanged', assignmentChangeHandler);
        window._mrfFormAssignmentHandler = assignmentChangeHandler;
```

In destroy() (line 549), add cleanup BEFORE the existing projectsListener cleanup (before line 553):

```javascript
    // Phase 7: Remove assignment change listener
    if (window._mrfFormAssignmentHandler) {
        window.removeEventListener('assignmentsChanged', window._mrfFormAssignmentHandler);
        delete window._mrfFormAssignmentHandler;
    }
```

Note: mrf-form.js uses a single variable pattern for listeners (not an array), so the assignment handler cleanup is a separate event listener cleanup, not pushed to an array. This matches the existing style.
  </action>
  <verify>
1. grep mrf-form.js for "cachedProjects" -- in declaration, in onSnapshot callback, and in populateProjectDropdown
2. grep mrf-form.js for "populateProjectDropdown" -- in onSnapshot callback (call) and in function definition and in assignmentsChanged handler
3. grep mrf-form.js for "getAssignedProjectCodes" -- once in populateProjectDropdown
4. grep mrf-form.js for "_mrfFormAssignmentHandler" -- in init (register) and destroy (cleanup)
5. Confirm the hint message "No projects assigned -- contact your admin" appears in the empty-state branch when assignedCodes is not null
  </verify>
  <done>
mrf-form.js project dropdown filters by assigned projects for operations_user. Cached snapshot data enables re-population without re-querying Firestore when assignments change. Empty dropdown shows distinct hint message for scoped users vs genuinely empty project collection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add assignment filter to procurement.js MRF list</name>
  <files>app/views/procurement.js</files>
  <action>
Two changes to procurement.js. Both are additive. ONLY the MRF list (mrfs tab) is filtered. No other tab is touched.

**Change A: Add assignment filter inside the loadMRFs() onSnapshot callback**

The loadMRFs() function is at line 454. The onSnapshot callback collects allMRFs (lines 461-468), then splits them into materialMRFs and transportMRFs at lines 470-472.

The current code after collection is:
```javascript
        // Separate by request type
        const materialMRFs = allMRFs.filter(m => m.request_type !== 'service');
        const transportMRFs = allMRFs.filter(m => m.request_type === 'service');
```

Insert the assignment filter BETWEEN the allMRFs collection loop and the material/transport split. Add these lines after the `allMRFs.push(...)` loop closes (after line 468) and BEFORE the "Separate by request type" comment (before line 470):

```javascript
        // Phase 7: Scope MRF list to assigned projects for operations_user.
        // Runs BEFORE the material/transport split so both lists are filtered.
        const assignedCodes = window.getAssignedProjectCodes?.();
        let scopedMRFs = allMRFs;
        if (assignedCodes !== null) {
            scopedMRFs = allMRFs.filter(mrf =>
                // Defensively include legacy MRFs that lack project_code (pre-Phase-4 data)
                !mrf.project_code || assignedCodes.includes(mrf.project_code)
            );
        }
```

Then change the two split lines from using `allMRFs` to using `scopedMRFs`:
```javascript
        const materialMRFs = scopedMRFs.filter(m => m.request_type !== 'service');
        const transportMRFs = scopedMRFs.filter(m => m.request_type === 'service');
```

Everything after that (sort, renderMRFList) stays exactly as written.

**Change B: Subscribe to assignmentsChanged in init() and clean up in destroy()**

IMPORTANT: procurement.js does NOT currently have any permissionsChanged listener (unlike projects.js). This is the first event listener of this kind added to this view. Use the same guard pattern to prevent re-registration on tab switches.

In init() (line 325), after the `attachWindowFunctions()` call (line 329) and before the `try` block (line 333), add:

```javascript
    // Phase 7: Re-filter MRF list when assignments change
    // Guard: only register once (init() is called on every tab switch without destroy)
    if (!window._procurementAssignmentHandler) {
        const assignmentChangeHandler = () => {
            console.log('[Procurement] Assignments changed, re-filtering MRF list...');
            // The onSnapshot data is still in memory; re-trigger the filter+render
            // by calling loadMRFs() which will fire the existing listener callback.
            // Actually: the listener callback already ran and populated allMRFs.
            // We need to re-run the filter logic. The simplest approach: just
            // call loadMRFs() -- but that creates a DUPLICATE listener.
            // Instead, store a reference to the latest allMRFs and re-run inline.
            // Cleanest: extract a reRenderMRFs function. See below.
            reFilterAndRenderMRFs();
        };
        window.addEventListener('assignmentsChanged', assignmentChangeHandler);
        window._procurementAssignmentHandler = assignmentChangeHandler;
    }
```

Wait -- we need a reFilterAndRenderMRFs function. The onSnapshot callback in loadMRFs() does collection + filter + split + sort + render all inline. We cannot re-call the callback. We need to store the raw allMRFs data at module scope so the assignment handler can re-filter it.

**Additional change needed:** Add a module-level variable to hold the unfiltered MRF data. Place it with the other module-level state at the top of the file (around lines 15-29):

```javascript
let cachedAllMRFs = [];   // Holds raw MRF snapshot for re-filtering on assignment change
```

Then in the loadMRFs() onSnapshot callback, AFTER the collection loop (after line 468, right before the Phase 7 filter block you just added), add:

```javascript
        // Cache raw data for re-filtering on assignment change (Phase 7)
        cachedAllMRFs = [...allMRFs];
```

And add the reFilterAndRenderMRFs function at module scope (place it near loadMRFs, after the loadMRFs function):

```javascript
/**
 * Re-apply the assignment filter and re-render MRF list.
 * Uses cachedAllMRFs (set by the loadMRFs onSnapshot callback) so we do not
 * create duplicate Firestore listeners.
 */
function reFilterAndRenderMRFs() {
    const assignedCodes = window.getAssignedProjectCodes?.();
    let scopedMRFs = cachedAllMRFs;
    if (assignedCodes !== null) {
        scopedMRFs = cachedAllMRFs.filter(mrf =>
            !mrf.project_code || assignedCodes.includes(mrf.project_code)
        );
    }

    const materialMRFs = scopedMRFs.filter(m => m.request_type !== 'service');
    const transportMRFs = scopedMRFs.filter(m => m.request_type === 'service');

    const sortByDeadline = (a, b) => {
        const dateA = new Date(a.date_needed);
        const dateB = new Date(b.date_needed);
        return dateA - dateB;
    };

    materialMRFs.sort(sortByDeadline);
    transportMRFs.sort(sortByDeadline);

    console.log('[Procurement] Re-filtered - Material:', materialMRFs.length, 'Transport:', transportMRFs.length);
    renderMRFList(materialMRFs, transportMRFs);
}
```

Now update the init() assignment handler to simply call reFilterAndRenderMRFs():
```javascript
    if (!window._procurementAssignmentHandler) {
        const assignmentChangeHandler = () => {
            console.log('[Procurement] Assignments changed, re-filtering MRF list...');
            reFilterAndRenderMRFs();
        };
        window.addEventListener('assignmentsChanged', assignmentChangeHandler);
        window._procurementAssignmentHandler = assignmentChangeHandler;
    }
```

In destroy() (line 354), add cleanup BEFORE the listeners.forEach block (before line 358):

```javascript
    // Phase 7: Remove assignment change listener
    if (window._procurementAssignmentHandler) {
        window.removeEventListener('assignmentsChanged', window._procurementAssignmentHandler);
        delete window._procurementAssignmentHandler;
    }

    // Phase 7: Clear cached MRF data
    cachedAllMRFs = [];
```
  </action>
  <verify>
1. grep procurement.js for "cachedAllMRFs" -- in declaration, in onSnapshot callback (cache write), and in reFilterAndRenderMRFs
2. grep procurement.js for "reFilterAndRenderMRFs" -- in function definition and in the assignmentsChanged handler
3. grep procurement.js for "getAssignedProjectCodes" -- in loadMRFs callback and in reFilterAndRenderMRFs
4. grep procurement.js for "_procurementAssignmentHandler" -- in init (register with guard) and destroy (cleanup)
5. grep procurement.js for "scopedMRFs" -- in loadMRFs callback (two occurrences: declaration and split lines)
6. Confirm no changes to supplier, PR/TR generation, or PO tracking functions
  </verify>
  <done>
procurement.js MRF list filters by assigned projects for operations_user before the material/transport split. Raw MRF data is cached at module scope for re-filtering when assignmentsChanged fires. Legacy MRFs without project_code are always shown. Guard pattern prevents duplicate listener registration across tab switches. Only the mrfs tab is affected.
  </done>
</task>

</tasks>

<verification>
1. mrf-form.js project dropdown filtered by assignment for operations_user
2. mrf-form.js shows "No projects assigned -- contact your admin" when operations_user has zero assigned projects
3. mrf-form.js re-populates on assignmentsChanged without page reload
4. procurement.js MRF list filtered before material/transport split
5. procurement.js legacy MRFs (no project_code) always shown
6. procurement.js re-filters on assignmentsChanged via reFilterAndRenderMRFs
7. procurement.js guard pattern on assignmentsChanged listener (no duplicate on tab switch)
8. No changes to supplier management, PR/TR generation, PO tracking, or any other tab
9. home.js is not touched
</verification>

<success_criteria>
- Operations Users see only MRFs for assigned projects in procurement
- Operations Users see only assigned projects in the MRF form dropdown
- Both views react to assignment changes in real time
- Legacy data without project_code is never accidentally hidden
- Supplier, PR/TR, and PO tabs remain completely unchanged
- No new Firestore listeners added -- filtering is client-side on cached data
</success_criteria>

<output>
After completion, create `.planning/phases/07-project-assignment-system/07-04-SUMMARY.md`
</output>
