---
phase: 06-role-infrastructure-real-time-permissions
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - app/auth.js
  - app/router.js
  - index.html
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Permissions load automatically when active user with role signs in"
    - "Role changes trigger permission listener cleanup and reinitialization"
    - "Navigation hides tabs user cannot access"
    - "Direct URL access to unpermitted route shows Access Denied"
    - "Permission changes propagate to UI without logout"
  artifacts:
    - path: "app/auth.js"
      provides: "Enhanced auth observer with permission integration"
      contains: "initPermissionsObserver"
    - path: "app/router.js"
      provides: "Permission-aware routing with access denied handling"
      contains: "hasTabAccess"
    - path: "index.html"
      provides: "Navigation with data-route attributes for permission filtering"
      contains: "data-route"
  key_links:
    - from: "app/auth.js"
      to: "app/permissions.js"
      via: "import and initPermissionsObserver call"
      pattern: "import.*permissions.*initPermissionsObserver"
    - from: "app/router.js"
      to: "window.hasTabAccess"
      via: "permission check before navigation"
      pattern: "hasTabAccess.*access"
    - from: "app/auth.js (module level, line ~22)"
      to: "permissionsChanged event"
      via: "window.addEventListener at module scope"
      pattern: "addEventListener.*permissionsChanged"
---

<objective>
Integrate permissions module with auth observer, router, and navigation

Purpose: Wire up the permissions system so that permissions load on login, update on role changes, filter navigation visibility, and block access to unpermitted routes. This creates the enforcement layer for tab-based access control.

Output: Fully integrated permission system where navigation and routing respect user permissions in real-time
</objective>

<execution_context>
@C:\Users\Admin\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Admin\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-role-infrastructure-real-time-permissions/06-RESEARCH.md
@.planning/phases/06-role-infrastructure-real-time-permissions/06-01-SUMMARY.md
@app/auth.js
@app/router.js
@app/permissions.js
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance auth.js with permission integration and permissionsChanged listener</name>
  <files>app/auth.js</files>
  <action>
Integrate permissions module into auth observer to initialize and cleanup permissions based on user state.

**Add import at top (after existing imports, around line 21):**
```javascript
import { initPermissionsObserver, destroyPermissionsObserver } from './permissions.js';
```

**CRITICAL - Add permissionsChanged event listener at MODULE LEVEL (line ~22-30, after imports, before any function definitions):**

This listener MUST be at module level scope so it's registered once when auth.js loads and persists for the lifetime of the application.

```javascript
// ========================================
// PERMISSION CHANGE LISTENER (MODULE LEVEL)
// Updates navigation when permissions change (PERM-18)
// ========================================
window.addEventListener('permissionsChanged', (event) => {
    console.log('[Auth] Permissions changed, updating navigation');
    const user = getCurrentUser();
    if (user) {
        updateNavForAuth(user);
    }
});
```

**Enhance initAuthObserver() in the signed-in block (after userData check, around line 197-227):**

1. **After setting currentUser and before dispatching authStateChanged event:**
   ```javascript
   // Initialize permissions if user is active with a role (PERM-16, PERM-17)
   if (userData.status === 'active' && userData.role) {
       await initPermissionsObserver(currentUser);
   }
   ```

2. **In the user document onSnapshot listener (around line 235-261), detect role changes:**

   After `currentUser = { uid: user.uid, ...updatedUserData };` add:
   ```javascript
   // Detect role change (PERM-19) - reinitialize permission listener
   if (previousRole !== updatedUserData.role) {
       console.log('[Auth] Role changed:', previousRole, '->', updatedUserData.role);

       if (updatedUserData.status === 'active' && updatedUserData.role) {
           // Reinitialize permissions with new role
           await initPermissionsObserver(currentUser);
       } else {
           // No valid role, destroy permissions
           destroyPermissionsObserver();
       }
   }
   ```

   Note: Store `previousRole` before updating currentUser to detect changes:
   ```javascript
   const previousRole = currentUser?.role;
   currentUser = { uid: user.uid, ...updatedUserData };
   ```

3. **In the signed-out block (around line 272-284), cleanup permissions:**
   ```javascript
   // Clean up permissions observer
   destroyPermissionsObserver();
   ```

**IMPORTANT:** The existing deactivation handling (AUTH-09) must remain intact. Only ADD permission handling, don't modify existing logout-on-deactivate logic.

**Console logging:** Existing `[Auth]` prefix pattern.
  </action>
  <verify>
Login as active user with role -> console shows "[Permissions] Permissions loaded". Logout -> console shows "[Permissions] Destroying permissions observer". No errors in console.
  </verify>
  <done>
auth.js enhanced: permissionsChanged event listener at module level (after imports), permissions initialize on login for active users with roles, cleanup on logout, role change detection triggers permission reinitialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add data-route attributes to navigation and permission-based filtering</name>
  <files>index.html, app/auth.js</files>
  <action>
**Part A: Update index.html navigation with data-route attributes**

Modify the nav-links div to include data-route attributes on each link:
```html
<div class="nav-links">
    <a href="#/" class="nav-link" data-route="dashboard">Home</a>
    <a href="#/clients" class="nav-link" data-route="clients">Clients</a>
    <a href="#/projects" class="nav-link" data-route="projects">Projects</a>
    <a href="#/mrf-form" class="nav-link" data-route="mrf_form">Material Request</a>
    <a href="#/procurement" class="nav-link" data-route="procurement">Procurement</a>
    <a href="#/finance" class="nav-link" data-route="finance">Finance</a>
    <button id="logoutBtn" class="nav-logout-btn" onclick="handleLogout()" style="display: none;">
        Log Out
    </button>
</div>
```

Note: data-route values match the tab IDs in role_templates (dashboard, clients, projects, mrf_form, procurement, finance).

**Part B: Update auth.js updateNavForAuth function**

Enhance the existing `updateNavForAuth(user)` function to filter navigation based on permissions:

```javascript
function updateNavForAuth(user) {
    const logoutBtn = document.getElementById('logoutBtn');
    const navLinks = document.querySelectorAll('.nav-link[data-route]');

    if (user) {
        // Show logout button for authenticated users
        if (logoutBtn) logoutBtn.style.display = 'block';

        // Filter navigation based on permissions (PERM-13, PERM-14)
        const permissions = window.getCurrentPermissions?.();

        navLinks.forEach(link => {
            const route = link.getAttribute('data-route');
            const hasAccess = permissions?.tabs?.[route]?.access ?? true; // Default to true if no permissions loaded yet

            link.style.display = hasAccess ? '' : 'none';
        });
    } else {
        // Hide logout button for unauthenticated users
        if (logoutBtn) logoutBtn.style.display = 'none';

        // Show all nav links for unauthenticated users (route protection comes in Phase 10)
        navLinks.forEach(link => {
            link.style.display = '';
        });
    }
}
```

Note: The permissionsChanged event listener was added in Task 1 at module level, so it will call updateNavForAuth when permissions change.
  </action>
  <verify>
Login as user with role -> navigation shows only permitted tabs. In Firestore, change role permissions -> navigation updates without logout. Finance role user should NOT see Procurement tab, Procurement role user should NOT see Finance tab.
  </verify>
  <done>
Navigation filtering implemented: nav links have data-route attributes, updateNavForAuth filters based on permissions, permissionsChanged event (from Task 1) triggers nav update for real-time permission changes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add permission checks to router with Access Denied page</name>
  <files>app/router.js</files>
  <action>
Enhance router to check permissions before navigating to protected routes.

**Add route-to-permission mapping at top of file:**
```javascript
// Map routes to permission tab IDs
const routePermissionMap = {
    '/': 'dashboard',
    '/clients': 'clients',
    '/projects': 'projects',
    '/project-detail': 'projects',  // Detail view uses projects permission
    '/mrf-form': 'mrf_form',
    '/procurement': 'procurement',
    '/finance': 'finance',
    '/role-config': 'role_config'   // Admin route (future)
};

// Routes that don't require permission checks (auth routes)
const publicRoutes = ['/login', '/register', '/pending'];
```

**Enhance navigate() function - add permission check after route validation, before showLoading:**

```javascript
export async function navigate(path, tab = null, param = null) {
    // Validate route
    const route = routes[path];
    if (!route) {
        console.error('Route not found:', path);
        window.location.hash = '#/';
        return;
    }

    // Permission check for protected routes (PERM-14)
    if (!publicRoutes.includes(path)) {
        const permissionKey = routePermissionMap[path];
        const hasAccess = window.hasTabAccess?.(permissionKey);

        // IMPORTANT: Use strict equality check to distinguish:
        // - false = no permission (block)
        // - undefined = not loaded yet (allow, pending state)
        // - true = has permission (allow)
        if (hasAccess === false) {
            console.warn('[Router] Access denied to:', path);
            showAccessDenied();
            return;
        }
    }

    // Show loading
    showLoading(true);
    // ... rest of existing code
}
```

**Add showAccessDenied() function:**
```javascript
/**
 * Show access denied page
 */
function showAccessDenied() {
    const appContainer = document.getElementById('app-container');
    if (!appContainer) return;

    appContainer.innerHTML = `
        <div class="container" style="padding: 4rem 2rem;">
            <div class="card">
                <div class="card-body">
                    <div class="empty-state">
                        <div class="empty-state-icon">ðŸ”’</div>
                        <h3>Access Denied</h3>
                        <p>You don't have permission to access this page.</p>
                        <p style="color: var(--gray-500); font-size: 0.875rem; margin-top: 0.5rem;">
                            Contact your administrator if you believe this is an error.
                        </p>
                        <button class="btn btn-primary" onclick="location.hash='#/'" style="margin-top: 1rem;">
                            Go to Dashboard
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
}
```

**Console logging:** Use existing `[Router]` prefix.
  </action>
  <verify>
Login as Finance role user -> manually navigate to #/procurement via URL bar -> shows "Access Denied" page. Click "Go to Dashboard" returns to home.
  </verify>
  <done>
Router enhanced with permission checks: protected routes validate access before navigation using strict equality (hasAccess === false), unpermitted access shows Access Denied page with dashboard redirect.
  </done>
</task>

</tasks>

<verification>
1. Login as user with assigned role -> permissions load (console log)
2. Navigation shows only tabs user has access to
3. Manually navigating to unpermitted route shows Access Denied
4. Change role permissions in Firestore -> navigation updates immediately (no logout)
5. Change user's role in Firestore -> permissions reload (console shows role change detection)
6. Logout -> permissions cleaned up (console log)
7. Existing auth functionality (deactivation handling) still works
</verification>

<success_criteria>
- Permissions integrate with auth observer (load on login, cleanup on logout)
- permissionsChanged event listener at module level in auth.js (after imports, before functions)
- Role changes detected and permissions reinitialized
- Navigation filters based on tab access permissions
- Router blocks access to unpermitted routes with Access Denied page (using hasAccess === false)
- Permission changes propagate to UI in real-time (no logout required)
- No breaking changes to existing auth or routing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/06-role-infrastructure-real-time-permissions/06-02-SUMMARY.md`
</output>
