# Plan 10-01: Route Guards & Unauthenticated Redirect

**Phase:** 10 - Route Protection & Session Security
**Requirements:** SEC-01, SEC-03
**Dependencies:** Phase 9 complete

---

## Goal

Implement authentication guards that redirect unauthenticated users to login BEFORE attempting to load protected routes, eliminating the flash of protected content.

---

## Success Criteria

1. ✅ Unauthenticated users accessing any protected route are immediately redirected to `/login`
2. ✅ No flash of protected content (dashboard, projects, etc.)
3. ✅ Auth check happens synchronously before route loading
4. ✅ Public routes (`/login`, `/register`, `/pending`) remain accessible without auth
5. ✅ Authenticated users navigate normally without extra redirects

---

## Current State

**File:** `app/router.js`
**Lines 186-199:** Permission check exists but no auth check
```javascript
// Permission check for protected routes (PERM-14)
if (!publicRoutes.includes(path)) {
    const permissionKey = routePermissionMap[path];
    const hasAccess = window.hasTabAccess?.(permissionKey);

    if (hasAccess === false) {
        console.warn('[Router] Access denied to:', path);
        showAccessDenied();
        return;
    }
}
```

**Problem:**
- Checks permissions but NOT authentication
- Unauthenticated users can navigate to `#/` and see brief flash of content
- Permission check happens after route loading starts

---

## Implementation Plan

### Step 1: Add Authentication Guard to Router

**File:** `app/router.js`
**Location:** Before permission check in `navigate()` function

**Add auth check:**
```javascript
export async function navigate(path, tab = null, param = null) {
    // Validate route
    const route = routes[path];
    if (!route) {
        console.error('Route not found:', path);
        window.location.hash = '#/';
        return;
    }

    // STEP 1: Authentication check for protected routes (SEC-01)
    if (!publicRoutes.includes(path)) {
        const user = window.getCurrentUser?.();

        if (!user) {
            // Not authenticated - redirect to login
            console.warn('[Router] Unauthenticated access attempt:', path);
            window.location.hash = '#/login';
            return;
        }

        // Check if user is pending or rejected
        if (user.status === 'pending' || user.status === 'rejected') {
            // Pending/rejected users should only see /pending page
            if (path !== '/pending') {
                console.warn('[Router] Pending/rejected user redirected to pending page');
                window.location.hash = '#/pending';
                return;
            }
        }
    }

    // STEP 2: Permission check for protected routes (existing)
    if (!publicRoutes.includes(path)) {
        const permissionKey = routePermissionMap[path];
        const hasAccess = window.hasTabAccess?.(permissionKey);

        if (hasAccess === false) {
            console.warn('[Router] Access denied to:', path);
            showAccessDenied();
            return;
        }
    }

    // Continue with existing route loading...
    showLoading(true);
    // ... rest of function unchanged
}
```

**Key points:**
- Auth check happens FIRST, before permission check
- Synchronous check using `getCurrentUser()` (already loaded)
- No async operations - instant redirect
- Pending/rejected users can only access `/pending`

---

### Step 2: Add Auth Check to Hash Change Handler

**File:** `app/router.js`
**Location:** `handleHashChange()` function (line 292)

**Current:**
```javascript
function handleHashChange() {
    const { path, tab, subpath } = parseHash();

    // Handle detail routes
    if (path === '/projects' && tab === 'detail' && subpath) {
        navigate('/project-detail', null, subpath);
        return;
    }

    navigate(path, tab);
}
```

**No change needed** - `navigate()` will handle auth check

---

### Step 3: Handle Initial Route on App Load

**File:** `app/router.js`
**Location:** `initRouter()` function (line 307)

**Current:**
```javascript
export function initRouter() {
    console.log('Initializing router...');

    // Listen for hash changes
    window.addEventListener('hashchange', handleHashChange);

    // Handle initial route
    const { path, tab, subpath } = parseHash();

    // Handle detail routes on initial load
    if (path === '/projects' && tab === 'detail' && subpath) {
        navigate('/project-detail', null, subpath);
    } else {
        navigate(path, tab);
    }
}
```

**Issue:** Router initializes before auth state is known

**Solution:** Wait for auth state before initial navigation

**Modified:**
```javascript
export function initRouter() {
    console.log('Initializing router...');

    // Listen for hash changes
    window.addEventListener('hashchange', handleHashChange);

    // Wait for auth state before initial navigation (SEC-01)
    // Auth observer calls handleInitialRoute() when ready
    console.log('[Router] Waiting for auth state before navigation...');
}

/**
 * Handle initial route after auth state is known
 * Called by auth observer in auth.js
 */
export function handleInitialRoute() {
    console.log('[Router] Auth state ready, handling initial route');

    const { path, tab, subpath } = parseHash();

    // Handle detail routes on initial load
    if (path === '/projects' && tab === 'detail' && subpath) {
        navigate('/project-detail', null, subpath);
    } else {
        navigate(path, tab);
    }
}

// Expose to window for auth.js
window.handleInitialRoute = handleInitialRoute;
```

---

### Step 4: Update Auth Observer to Trigger Initial Route

**File:** `app/auth.js`
**Location:** `initAuthObserver()` function (line 195)

**Add after auth state is determined:**

```javascript
export function initAuthObserver() {
    onAuthStateChanged(auth, async (user) => {
        // ... existing user document fetch and status handling ...

        if (user) {
            // ... existing user setup ...

            // Trigger initial route after auth state is known (SEC-01)
            if (typeof window.handleInitialRoute === 'function') {
                window.handleInitialRoute();
            }
        } else {
            // User signed out
            console.log('[Auth] User signed out');

            // ... existing cleanup ...

            // Trigger initial route for unauthenticated state (SEC-01)
            if (typeof window.handleInitialRoute === 'function') {
                window.handleInitialRoute();
            }
        }
    });
}
```

**Flow:**
1. App loads → `initRouter()` called
2. Router waits for auth state
3. Auth observer fires → determines user state
4. Calls `handleInitialRoute()` → navigation begins
5. Auth guard in `navigate()` redirects if needed

---

### Step 5: Add Loading State During Auth Check

**File:** `index.html`
**Add initial loading indicator:**

```html
<body>
    <!-- Loading Indicator (shown until auth state known) -->
    <div id="initial-loading" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        background: white;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    ">
        <div style="text-align: center;">
            <div class="spinner"></div>
            <p style="color: #64748b; margin-top: 1rem;">Loading...</p>
        </div>
    </div>

    <!-- Navigation (hidden until auth state known) -->
    <nav class="navbar" id="navbar" style="display: none;">
        <!-- ... existing nav ... -->
    </nav>

    <!-- App Container -->
    <div id="app-container"></div>
</body>
```

**File:** `app/router.js`
**Add to `handleInitialRoute()`:**

```javascript
export function handleInitialRoute() {
    console.log('[Router] Auth state ready, handling initial route');

    // Hide initial loading indicator
    const initialLoading = document.getElementById('initial-loading');
    if (initialLoading) {
        initialLoading.style.display = 'none';
    }

    // Show navbar
    const navbar = document.getElementById('navbar');
    if (navbar) {
        navbar.style.display = '';
    }

    // Navigate to initial route
    const { path, tab, subpath } = parseHash();
    // ... rest of function
}
```

**Benefits:**
- No flash of content
- Clean loading experience
- Prevents FOUC (Flash of Unstyled Content)

---

## Testing Plan

### Test 1: Unauthenticated Access to Protected Route
```
1. Open browser in incognito mode
2. Navigate to http://localhost:8000/#/
3. Expected: Immediate redirect to #/login
4. Expected: NO flash of dashboard content
5. Expected: Loading indicator shown briefly
```

### Test 2: Direct URL Access
```
1. Not logged in
2. Navigate to http://localhost:8000/#/projects
3. Expected: Redirect to #/login
4. Expected: No content flash
```

### Test 3: Authenticated User Normal Navigation
```
1. Log in as active user
2. Click navigation links
3. Expected: Normal navigation, no extra redirects
4. Expected: Content loads as before
```

### Test 4: Pending User Redirect
```
1. Log in as pending user
2. Try to navigate to #/
3. Expected: Redirect to #/pending
4. Expected: Cannot access other routes
```

### Test 5: Public Routes Accessible
```
1. Not logged in
2. Navigate to #/login
3. Expected: Login page loads normally
4. Navigate to #/register
5. Expected: Register page loads normally
```

---

## Files Changed

1. **app/router.js**
   - Add auth guard to `navigate()` function
   - Modify `initRouter()` to wait for auth state
   - Add `handleInitialRoute()` function
   - Expose `handleInitialRoute` to window

2. **app/auth.js**
   - Call `handleInitialRoute()` after auth state determined
   - Both authenticated and unauthenticated paths

3. **index.html**
   - Add initial loading indicator
   - Hide navbar until auth state known

---

## Edge Cases

### Case 1: User on Protected Route Gets Deactivated
**Handled by:** Existing auth observer (real-time listener)
**Behavior:** Signs out user, redirects to login
**No change needed**

### Case 2: Hash Changes While Loading
**Handled by:** `hashchange` event listener
**Behavior:** Calls `navigate()` which does auth check
**No change needed**

### Case 3: User Clicks Logout
**Handled by:** Existing logout handler
**Behavior:** Signs out, redirects to login
**No change needed**

### Case 4: Auth State Still Loading
**Handled by:** Wait for `onAuthStateChanged` callback
**Behavior:** Shows loading indicator until ready
**Implemented in Step 5**

---

## Performance Impact

- **Auth check:** Synchronous, instant (<1ms)
- **Loading indicator:** Shown ~100-200ms (auth state check time)
- **No network calls added:** Uses existing `getCurrentUser()`
- **Net impact:** Negligible, actually faster UX (no content flash)

---

## Security Impact

**Before:**
- Unauthenticated users could access routes briefly
- Content flash exposes data structure
- Poor security posture

**After:**
- Immediate auth check before route loading
- Zero content exposure
- Defense in depth (auth + permission checks)

---

## Rollback Plan

If issues arise:
1. Remove auth guard from `navigate()` function
2. Restore original `initRouter()` behavior
3. Remove `handleInitialRoute()` function
4. Remove initial loading indicator from index.html
5. System returns to Phase 9 behavior

---

## Success Metrics

- [ ] Zero flash of protected content for unauthenticated users
- [ ] Immediate redirect to login (<100ms perceived)
- [ ] No broken navigation for authenticated users
- [ ] All 5 test cases pass
- [ ] No performance degradation

---

## Next Steps

After Plan 10-01 complete:
- **Plan 10-02:** Deep Link Support (save/restore intended route)
- **Plan 10-03:** Navigation visibility + Super Admin minimum = 2
- **Plan 10-04:** End-to-end verification
