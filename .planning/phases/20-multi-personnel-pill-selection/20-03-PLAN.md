---
phase: 20-multi-personnel-pill-selection
plan: 03
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - app/views/project-detail.js
autonomous: true

must_haves:
  truths:
    - "Project detail page displays all assigned personnel as pills in Card 1"
    - "View-only users see personnel as disabled pills (no X buttons)"
    - "Editable personnel field shows pills with X buttons and a search input"
    - "Adding or removing a personnel pill immediately saves to Firestore"
    - "Existing single-personnel and freetext projects display correctly as pills"
    - "Legacy freetext personnel (no user ID) renders as a gray pill"
    - "Re-render from onSnapshot does not destroy pill state when input is focused"
  artifacts:
    - path: "app/views/project-detail.js"
      provides: "Pill display and inline editing for personnel on project detail page"
      contains: "pill-input-container"
  key_links:
    - from: "app/views/project-detail.js"
      to: "app/utils.js"
      via: "import { normalizePersonnel }"
      pattern: "normalizePersonnel"
    - from: "app/views/project-detail.js"
      to: "Firestore projects collection"
      via: "updateDoc with personnel_user_ids and personnel_names arrays"
      pattern: "personnel_user_ids.*personnel_names"
---

<objective>
Transform the project detail page personnel field from a single-select datalist input to a pill display with inline add/remove editing that saves immediately on each action.

Purpose: The detail page is the primary place users VIEW personnel assignments and make quick edits. Currently it uses a datalist input with save-on-blur. Since pills are multi-element, saving must happen on each add/remove action instead of on blur.

Output: Updated app/views/project-detail.js with pill rendering in the detail view, inline add/remove with immediate Firestore saves, and backward-compatible display of all legacy data formats.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-multi-personnel-pill-selection/20-RESEARCH.md
@.planning/phases/20-multi-personnel-pill-selection/20-01-SUMMARY.md
@app/views/project-detail.js
@app/utils.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace personnel datalist with pill display/edit in project-detail.js</name>
  <files>app/views/project-detail.js</files>
  <action>
  This task modifies app/views/project-detail.js to replace the single-select datalist personnel field with a pill-based display and inline editing component. All changes are in this single file.

  **1. Add import for normalizePersonnel:**
  Update the import from `../utils.js` (line 7) to include `normalizePersonnel`:
  ```javascript
  import { formatCurrency, formatDate, showLoading, showToast, normalizePersonnel } from '../utils.js';
  ```

  **2. Add module-level state for personnel pills:**
  After `let currentExpense = ...` (around line 14), add:
  ```javascript
  let detailSelectedPersonnel = []; // Array of { id: string, name: string } for pill state
  let personnelClickOutsideHandler = null;
  ```

  **3. Replace the Assigned Personnel field in renderProjectDetail():**
  Find the personnel form group in renderProjectDetail() (around lines 287-291):
  ```html
  <div class="form-group" style="margin-bottom: 0;">
      <label style="margin-bottom: 0.25rem;">Assigned Personnel</label>
      <input type="text" data-field="personnel" list="personnelUsersList" value="${currentProject.personnel_name || currentProject.personnel || ''}" onblur="window.saveField('personnel', this.value)" placeholder="Type name to search..." autocomplete="off" ${!showEditControls ? 'disabled' : ''}>
      <datalist id="personnelUsersList"></datalist>
  </div>
  ```

  Replace with personnel pill display that uses normalizePersonnel():
  ```javascript
  <div class="form-group" style="margin-bottom: 0; position: relative;">
      <label style="margin-bottom: 0.25rem;">Assigned Personnel</label>
      ${(() => {
          const normalized = normalizePersonnel(currentProject);
          // Update module state for editing (but only if not currently focused)
          const pillSearchFocused = document.activeElement?.id === 'detailPersonnelSearch';
          if (!pillSearchFocused) {
              detailSelectedPersonnel = [];
              for (let i = 0; i < normalized.names.length; i++) {
                  detailSelectedPersonnel.push({
                      id: normalized.userIds[i] || '',
                      name: normalized.names[i]
                  });
              }
          }

          const pillsHtml = detailSelectedPersonnel.map(user => \`
              <span class="personnel-pill \${user.id ? '' : 'legacy'}" data-user-id="\${user.id || ''}">
                  \${user.name}
                  \${showEditControls ? \`<button type="button" class="pill-remove"
                      onmousedown="event.preventDefault(); window.removeDetailPersonnel('\${user.id || ''}', '\${user.name.replace(/'/g, "\\\\'")}')">&times;</button>\` : ''}
              </span>
          \`).join('');

          if (showEditControls) {
              return \`
                  <div class="pill-input-container" id="detailPillContainer"
                       onclick="document.getElementById('detailPersonnelSearch')?.focus()">
                      \${pillsHtml}
                      <input type="text"
                             class="pill-search-input"
                             id="detailPersonnelSearch"
                             data-field="personnel-pills"
                             placeholder="\${detailSelectedPersonnel.length === 0 ? 'Type name or email...' : ''}"
                             oninput="window.filterDetailPersonnel(this.value)"
                             onfocus="window.showDetailPersonnelDropdown()"
                             autocomplete="off">
                  </div>
                  <div class="pill-dropdown" id="detailPersonnelDropdown" style="display: none;"></div>
              \`;
          } else {
              // View-only mode: show pills without X buttons, no input
              return pillsHtml || '<span style="color: #94a3b8;">Not assigned</span>';
          }
      })()}
  </div>
  ```

  IMPORTANT: The above is complex template literal nesting. In practice, build this as a helper function `renderPersonnelPills(showEditControls)` that returns the HTML string, then call it in the template: `${renderPersonnelPills(showEditControls)}`. This is cleaner and avoids deeply nested template literals.

  **Better approach - use a helper function:**
  ```javascript
  function renderPersonnelPills(showEditControls) {
      const normalized = normalizePersonnel(currentProject);

      // Update module state (but only if search input is not focused, to preserve typing state)
      const searchFocused = document.activeElement?.id === 'detailPersonnelSearch';
      if (!searchFocused) {
          detailSelectedPersonnel = [];
          for (let i = 0; i < normalized.names.length; i++) {
              detailSelectedPersonnel.push({
                  id: normalized.userIds[i] || '',
                  name: normalized.names[i]
              });
          }
      }

      const pillsHtml = detailSelectedPersonnel.map(user => `
          <span class="personnel-pill ${user.id ? '' : 'legacy'}" data-user-id="${user.id || ''}">
              ${user.name}
              ${showEditControls ? `<button type="button" class="pill-remove"
                  onmousedown="event.preventDefault(); window.removeDetailPersonnel('${user.id || ''}', '${user.name.replace(/'/g, "\\'")}')">&times;</button>` : ''}
          </span>
      `).join('');

      if (!showEditControls) {
          return `
              <div class="form-group" style="margin-bottom: 0;">
                  <label style="margin-bottom: 0.25rem;">Assigned Personnel</label>
                  <div class="pill-input-container disabled">
                      ${pillsHtml || '<span style="color: #94a3b8; font-size: 0.875rem;">Not assigned</span>'}
                  </div>
              </div>`;
      }

      return `
          <div class="form-group" style="margin-bottom: 0; position: relative;">
              <label style="margin-bottom: 0.25rem;">Assigned Personnel</label>
              <div class="pill-input-container" id="detailPillContainer"
                   onclick="document.getElementById('detailPersonnelSearch')?.focus()">
                  ${pillsHtml}
                  <input type="text"
                         class="pill-search-input"
                         id="detailPersonnelSearch"
                         data-field="personnel-pills"
                         placeholder="${detailSelectedPersonnel.length === 0 ? 'Type name or email...' : ''}"
                         oninput="window.filterDetailPersonnel(this.value)"
                         onfocus="window.showDetailPersonnelDropdown()"
                         autocomplete="off">
              </div>
              <div class="pill-dropdown" id="detailPersonnelDropdown" style="display: none;"></div>
          </div>`;
  }
  ```

  Then in `renderProjectDetail()`, replace the old personnel form-group with:
  ```javascript
  ${renderPersonnelPills(showEditControls)}
  ```

  **4. Handle re-render protection:**
  The current code at line 244 already detects focused fields:
  ```javascript
  const focusedField = document.activeElement?.dataset?.field;
  ```
  Add a check for the personnel search input. After `renderProjectDetail()` renders the HTML, if `focusedField === 'personnel-pills'`, restore focus to the search input:
  ```javascript
  // After container.innerHTML = ... at the end of renderProjectDetail():
  if (focusedField === 'personnel-pills') {
      const searchInput = document.getElementById('detailPersonnelSearch');
      searchInput?.focus();
  }
  ```

  **5. Add filterDetailPersonnel function:**
  ```javascript
  function filterDetailPersonnel(searchText) {
      const dropdown = document.getElementById('detailPersonnelDropdown');
      if (!dropdown) return;

      const term = searchText.toLowerCase().trim();
      const selectedIds = detailSelectedPersonnel.map(u => u.id).filter(Boolean);

      const matches = term ? usersData.filter(user =>
          !selectedIds.includes(user.id) &&
          (user.full_name.toLowerCase().includes(term) ||
           user.email.toLowerCase().includes(term))
      ) : [];

      if (matches.length === 0) {
          dropdown.style.display = 'none';
          return;
      }

      dropdown.innerHTML = matches.slice(0, 10).map(user => `
          <div class="pill-dropdown-item"
               onmousedown="event.preventDefault(); window.selectDetailPersonnel('${user.id}', '${user.full_name.replace(/'/g, "\\'")}')">
              <strong>${user.full_name}</strong>
              <span style="color: #64748b; margin-left: 0.5rem;">${user.email}</span>
          </div>
      `).join('');

      dropdown.style.display = 'block';
  }
  ```

  **6. Add showDetailPersonnelDropdown function:**
  ```javascript
  function showDetailPersonnelDropdown() {
      const searchInput = document.getElementById('detailPersonnelSearch');
      if (searchInput?.value?.trim()) {
          filterDetailPersonnel(searchInput.value);
      }
  }
  ```

  **7. Add selectDetailPersonnel function (saves immediately):**
  ```javascript
  async function selectDetailPersonnel(userId, userName) {
      if (!currentProject) return;
      if (detailSelectedPersonnel.some(u => u.id === userId)) return;

      detailSelectedPersonnel.push({ id: userId, name: userName });

      // Save immediately to Firestore
      try {
          await updateDoc(doc(db, 'projects', currentProject.id), {
              personnel_user_ids: detailSelectedPersonnel.map(u => u.id).filter(Boolean),
              personnel_names: detailSelectedPersonnel.map(u => u.name),
              personnel_user_id: null,
              personnel_name: null,
              personnel: null,
              updated_at: new Date().toISOString()
          });
          console.log('[ProjectDetail] Personnel added:', userName);
      } catch (error) {
          console.error('[ProjectDetail] Error saving personnel:', error);
          showToast('Failed to add personnel', 'error');
          // Rollback the optimistic UI update
          detailSelectedPersonnel = detailSelectedPersonnel.filter(u => u.id !== userId);
      }

      // Clear search and close dropdown
      const searchInput = document.getElementById('detailPersonnelSearch');
      if (searchInput) {
          searchInput.value = '';
          searchInput.focus();
      }
      const dropdown = document.getElementById('detailPersonnelDropdown');
      if (dropdown) dropdown.style.display = 'none';

      // Note: onSnapshot will re-render with the saved data, which will rebuild pills
  }
  ```

  **8. Add removeDetailPersonnel function (saves immediately):**
  ```javascript
  async function removeDetailPersonnel(userId, userName) {
      if (!currentProject) return;

      const previousState = [...detailSelectedPersonnel];

      if (userId) {
          detailSelectedPersonnel = detailSelectedPersonnel.filter(u => u.id !== userId);
      } else {
          detailSelectedPersonnel = detailSelectedPersonnel.filter(u => u.name !== userName);
      }

      // Save immediately to Firestore
      try {
          await updateDoc(doc(db, 'projects', currentProject.id), {
              personnel_user_ids: detailSelectedPersonnel.map(u => u.id).filter(Boolean),
              personnel_names: detailSelectedPersonnel.map(u => u.name),
              personnel_user_id: null,
              personnel_name: null,
              personnel: null,
              updated_at: new Date().toISOString()
          });
          console.log('[ProjectDetail] Personnel removed:', userName || userId);
      } catch (error) {
          console.error('[ProjectDetail] Error removing personnel:', error);
          showToast('Failed to remove personnel', 'error');
          detailSelectedPersonnel = previousState;
      }

      // Note: onSnapshot will re-render with the saved data
  }
  ```

  **9. Add click-outside handler in init():**
  In `init()`, after `attachWindowFunctions()` (line 52), add:
  ```javascript
  personnelClickOutsideHandler = (e) => {
      const container = document.getElementById('detailPillContainer');
      const dropdown = document.getElementById('detailPersonnelDropdown');
      if (dropdown && container && !container.contains(e.target) && !dropdown.contains(e.target)) {
          dropdown.style.display = 'none';
      }
  };
  document.addEventListener('mousedown', personnelClickOutsideHandler);
  ```

  **10. Register window functions in attachWindowFunctions():**
  Add to the existing `attachWindowFunctions()` function (around lines 920-929):
  ```javascript
  window.selectDetailPersonnel = selectDetailPersonnel;
  window.removeDetailPersonnel = removeDetailPersonnel;
  window.filterDetailPersonnel = filterDetailPersonnel;
  window.showDetailPersonnelDropdown = showDetailPersonnelDropdown;
  ```

  **11. Update destroy() for cleanup:**
  In `destroy()` (around lines 139-177), add:
  ```javascript
  if (personnelClickOutsideHandler) {
      document.removeEventListener('mousedown', personnelClickOutsideHandler);
      personnelClickOutsideHandler = null;
  }
  detailSelectedPersonnel = [];

  delete window.selectDetailPersonnel;
  delete window.removeDetailPersonnel;
  delete window.filterDetailPersonnel;
  delete window.showDetailPersonnelDropdown;
  ```

  **12. Remove obsolete code:**
  - Delete `populatePersonnelDatalist()` function (around lines 179-186)
  - Remove the call to `populatePersonnelDatalist()` in the users onSnapshot callback (line 105)
  - In `saveField()`, remove the entire personnel case (the large `else if (fieldName === 'personnel')` block around lines 413-466). Personnel is now saved directly by selectDetailPersonnel/removeDetailPersonnel, not via saveField. If saveField is called with 'personnel' somehow, it should just fall through to the generic handler or be ignored.

  **Key implementation notes:**
  - Save happens on each add/remove, NOT on blur. This is because pills are multi-element and there is no single "blur" moment.
  - The onSnapshot listener will trigger re-render after each save. The `searchFocused` check in `renderPersonnelPills()` prevents destroying user input during re-render.
  - `data-field="personnel-pills"` on the search input allows the existing focused-field detection to work.
  - Legacy freetext personnel (no user ID) shows as a gray pill (`.personnel-pill.legacy` CSS class).
  - Use `onmousedown` with `event.preventDefault()` for dropdown items and pill remove buttons.
  - Limit dropdown to 10 results for performance.
  </action>
  <verify>
  1. Start dev server and navigate to a project detail page (#/projects/detail/CLMC_XXX_YYYY###)
  2. Verify existing single-personnel projects display as a blue pill
  3. Verify legacy freetext projects (if any) display as a gray pill
  4. Click the search input, type a name -- verify dropdown filters users
  5. Click a dropdown item -- verify pill appears AND Firestore updates immediately (check Firebase console)
  6. Click X on a pill -- verify it is removed AND Firestore updates immediately
  7. Verify already-selected users are excluded from dropdown
  8. Click outside -- verify dropdown closes
  9. Verify view-only users see pills without X buttons and no search input
  10. Verify no console errors during all operations
  11. Verify onSnapshot re-render does not destroy search input text while typing
  </verify>
  <done>
  - Project detail page displays all assigned personnel as pills
  - Blue pills for users with IDs, gray pills for legacy freetext personnel
  - View-only mode shows pills without remove buttons or search input
  - Adding a personnel pill saves immediately to Firestore with array format
  - Removing a personnel pill saves immediately to Firestore
  - Legacy fields (personnel, personnel_user_id, personnel_name) are nulled on every save
  - Click outside closes the dropdown
  - onSnapshot re-render preserved when search input is focused
  </done>
</task>

</tasks>

<verification>
1. Navigate to project detail for a project with single personnel -- displays as pill
2. Add a second personnel -- both display as pills, Firestore has arrays
3. Remove one -- Firestore updated, one pill remains
4. Navigate away and back -- pills persist from Firestore
5. View-only user sees pills without edit controls
6. No console errors throughout all operations
</verification>

<success_criteria>
- Project detail page uses pill display for all personnel
- Inline add/remove with immediate Firestore persistence
- Backward compatible with all legacy data formats
- View-only mode correctly disables editing
- No regressions in other project detail functionality (financial summary, status editing, expense modal)
</success_criteria>

<output>
After completion, create `.planning/phases/20-multi-personnel-pill-selection/20-03-SUMMARY.md`
</output>
